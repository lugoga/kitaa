{
  "hash": "4c067911fde48aa86354f5ce5108dca6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The basics of R programming\"\nauthor: \n  - name: Masumbuko Semba\n    url: https://semba.netlify.app\n    orcid: 0000-0002-5002-9747\n    affiliation: Nelson Mandela African Institution of Science and Technology\n    affiliation-url: https://semba.netlify.app/  \ncitation: \n    url: https://lugoga.github.io/kitaa/posts/rbasics/\nbibliography: ../blog.bib\ncsl:  ../elsevier.csl\ndate: \"2024-01-24\"\ncategories: [Data Science, R Basic]\ndescription: \"Data Science-R Basic\"\nimage: https://images.unsplash.com/photo-1634128221889-82ed6efebfc3?ixlib=rb-1.2.1&q=80&cs=tinysrgb&fm=jpg&crop=entropy&w=3600\ncode-fold: false\n\n---\n\n\n# R Basics, Functions, and Data Types\n\nIn this section, I will introduce you to R Basics, Functions, and Datatypes.\n\nIn this part, you will learn to:\n\n-   Appreciate the rationale for data analysis using R.\n\n-   Define objects and perform basic arithmetic and logical operations.\n\n-   Use pre-defined functions to perform operations on objects.\n\n-   Distinguish between various data types.\n\n## Installing R\n\n### why Install R and RStudio?\n\n-   To complete this course, you should install R locally on your computer. We also highly recommend installing RStudio, an integrated development environment (IDE), to edit and test your code.\n\n-   In order to complete some assignments in the course, you will need your own copy of R. You may also find it helpful to follow along with the course videos in R or RStudio.\n\n-   Both R and RStudio can be freely downloaded and installed.\n\n### Key Points\n\n-   You need to install R before using RStudio, which is an interactive desktop environment.\n\n-   Select base subdirectory in [CRAN](https://cran.r-project.org/) and click download.\n\n-   Select all default choices in the installation process.\n\n-   We recommend selecting English for language to help you better follow the course.\n\n-   You can try using the R console, but for productivity purposes, we can switch to RStudio.\n\n## Installing Rstudio\n\n### Key Points\n\n-   You can download the latest version of RStudio at the [RStudio website](https://posit.co/download/rstudio-desktop/).\n\n-   The free desktop version is more than enough for this course.\n\n-   Make sure to choose the version for your own operating system.\n\n-   Choose \"Yes\" for all defaults in the installation process.\n\n## Using RStudio for the First Time\n\n### Key Points\n\n-   The free desktop version of RStudio can be launched like other applications on your computer.\n\n-   When you start RStudio for the first time, you will see three panes. The left pane shows you the R console. On the right, the top pane includes three tabs, while the bottom pane shows you five tabs, file, plots, packages, help, and viewer.\n\n-   You can download a cheat sheet of the most common RStudio commands directly from RStudio by going to \"Help -\\> Cheat Sheets -\\> RStudio IDE Cheat Sheet.\"\n\n## Getting Started Using R\n\n### Key Points:\n\n-   R was developed by statisticians and data analysts as an interactive environment for data analysis.\n\n-   Some of the advantages of R are that:\n\n    -   it is free and open source;\n\n    -   it has the capability to save scripts;\n\n    -   there are numerous resources for learning;\n\n    -   it is easy for developers to share software implementation.\n\n-   Expressions are evaluated in the R console when you type the expression into the console and hit Return.\n\n-   A great advantage of R over point and click analysis software is that you can save your work as scripts.\n\n-   \"Base R\" is what you get after you first install R. Additional components are available via packages.\n\n### Some Addition Notes\n\nIn RStudio, you can upload additional functions and datasets in addition to the base R functions and datasets that come with R automatically. A common way to do this is by installing packages, which often contain extra functions and datasets. For this course, there are a few packages you will need to install. You only need to install each individual package once, but after you install a package, there are other steps you have to do whenever you want to use something from that package.\n\nTo install a package, you use the code `install.packages(\"package_name\", dependencies = TRUE)`.\n\nTo load a package, you use the code `library(package_name)`.\n\nIf you also want to use a dataset from a package you have loaded, then you use the code `data(dataset_name)`. To see the dataset, you can take the additional step of `View(dataset_name)`.\n\n## Installing Packahes\n\n### Note\n\nWe recommend installing packages through RStudio, rather than through R, and the code provided works in both R and RStudio. Once a package has been installed, it is technically added onto R (even if you use RStudio to install it), which is why packages must be re-installed when R is updated. However, since we use R through RStudio, any packages that are installed can be used in both R and RStudio, regardless of which one was used to install the packages.\n\n### key points\n\n-   The base version of R is quite minimal, but you can supplement its functions by installing additional packages.\n-   We will be using **tidyverse** and **dslabs** packages for this course.\n-   Install packages from R console: `install.packages(\"pkg_name\")`\n-   Install packages from RStudio interface: Tools \\> Install Packages (allows autocomplete)\n-   Once installed, we can use `library(pkg_name)` to load a package each time we want to use it\n\n### Additional Notes\n\n-   If you try to load a package with `library(blahblah)` and get a message like *Error in library(blahblah) : there is no package called 'blahblah'*, it means you need to install that package first with `install.packages()`.\n-   On the DataCamp interface we use for some problems in the course, you cannot install additional packages. The problems have been set up with the packages you need to solve them.\n-   You can add the option `dependencies = TRUE`, which tells R to install the other things that are necessary for the package or packages to run smoothly. Otherwise, you may need to install additional packages to unlock the full functionality of a package.\n-   Throughout the course materials and textbook, package names are in **bold**.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"dslabs\") # to install a single package\ninstall.packages(c(\"tidyverse\", \"dslabs\")) # to install two packages at the same time\ninstalled.packages() # to see the list of all installed packages\n```\n:::\n\n\n## Running Commands While Editing Scripts\n\n### Key Points\n\n-   RStudio has many useful features as an R editor, including the ability to **test code** easily as we write scripts and several **auto complete features**.\n\n-   Keyboard shortcuts:\n\n    -   **Save a script**: Ctrl+S on Windows and Command+S on Mac\n    -   **Run an entire script**: Ctrl+Shift+Enter on Windows Command+Shift+Return on Mac, or click \"Source\" on the editor pane\n    -   **Run a single line of script**: Ctrl+Enter on Windows and Command+Return on Mac while the cursor is pointing to that line, or select the chunk and click \"run\"\n    -   **Open a new script**: Ctrl+Shift+N on Windows and Command+Shift+N on Mac\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Here is an example how to running commends while editing scripts\nlibrary(tidyverse)\nlibrary(dslabs)\ndata(murders)\n\nmurders %>% \n  ggplot(aes(population, total, label=abb, color=region)) +\n  geom_label()\n```\n:::\n\n\n## R Basics\n\n### Key Points\n\n-   To define a variable, we may use the assignment symbol, `<-`.\n\n-   \n\n    ## There are two ways to see the value stored in a variable:\n\n    ```         \n    (1) type the variable name into the console and hit Return;\n    ```\n\n    -   \n\n        (2) use the `print()` function by typing `print(variable_name)` and hitting Return.\n\n-   Objects are things that are stored in named containers in R. They can be variables, functions, etc.\n\n-   The `ls()` function shows the names of the objects saved in your work space.\n\n### Code: example to solving the equation $x^{2} + x - 1 = 0$\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assigning values to variables\na <- 1\nb <- 1\nc <- -1\n\n# solving the quadratic equation\n(-b + sqrt(b^2 - 4*a*c))/(2*a)\n(-b - sqrt(b^2 - 4*a*c))/(2*a)\n```\n:::\n\n\n## Function\n\n### Key Points\n\n-   In general, to evaluate a function we need to use **parentheses**. If we type a function without parenthesis, R shows us the code for the function. Most functions also require an argument, that is, something to be written inside the parenthesis.\n\n-   To access **help** files, we may use the help function, `help(function_name)`, or write the question mark followed by the function name, ?function_name.\n\n-   The help file shows you the arguments the function is expecting, some of which are required and some are optional. If an argument is optional, a default value is assigned with the equal sign. The `args()` function also shows the arguments a function needs.\n\n-   To specify arguments, we use the equals sign. If no argument name is used, R assumes you're entering arguments in the order shown in the help file.\n\n-   Creating and saving a script makes code much easier to execute.\n\n-   To make your code more readable, **use intuitive variable names and include comments** (using the **\"\\#\"** symbol) to remind yourself why you wrote a particular line of code.\n\n## Data Types\n\n::: callout-note\n### Note\n\nThe code `data(\"dataset_name\")` and `data(dataset_name)` do the same thing. The code will work regardless of whether the quotes are present. It is a bit faster to leave out the quotes (as we do in the Code at the bottom of this page), so that is usually what we recommend, but it is your choice.\n:::\n\n### Key Points\n\n-   The function `class()` helps us determine the type of an object.\n\n-   **Data frames** can be thought of as tables with rows representing observations and columns representing different variables.\n\n-   To access data from columns of a data frame, we use the dollar sign symbol, `$`, which is called the accessor.\n\n-   A **vector** is an object consisting of several entries and can be a **numeric vector**, a **character vector**, or a **logical vector**.\n\n-   We **use quotes** to distinguish between variable names and character strings.\n\n-   Factors are useful for storing categorical data, and are more memory efficient than storing characters.\n\n::: callout-note\n### Knowledge Extension\n\n\n```{mermaid}\nflowchart LR\n  A{Data Type}---> B[numeric]\n  A{Data Type}--->C[integer]\n  A{Data Type} --->D[complex]\n  A{Data Type}--->E[character]\n  A{Data Type}--->F[logical]\n```\n\n:::\n\n[**Explanation**:**Numeric**: all real numbers with or without decimal values. e.g. 1, 2, 8, 1.1.**Integer(整数)**: specifies real values without decimal points. we use the suffix`L` to specify integer data.**Complex**: specify purely imaginary values in R. We use the suffix `i` to specify the imaginary part. e.g. 3 + 2i.**Character**:specify character or string values in a variable. `''` for character variables; `\"\"` for string variables.**Logical**: is known as boolean data type. It can only have two values: `TRUE` and `FALSE`]{.aside}\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# loading the dslabs package and the murders dataset\nlibrary(dslabs)\ndata(murders)\n\n# determining that the murders dataset is of the \"data frame\" class\nclass(murders)\n# finding out more about the structure of the object\nstr(murders)\n# showing the first 6 lines of the dataset\nhead(murders)\n\n# using the accessor operator to obtain the population column\nmurders$population\n# displaying the variable names in the murders dataset\nnames(murders)\n# determining how many entries are in a vector\npop <- murders$population\nlength(pop)\n# vectors can be of class numeric and character\nclass(pop)\nclass(murders$state)\n\n# logical vectors are either TRUE or FALSE\nz <- 3 == 2\nz\nclass(z)\n\n# factors are another type of class\nclass(murders$region)\n# obtaining the levels of a factor\nlevels(murders$region)\n```\n:::\n\n\n# Vectors, Sorting\n\nIn this section, I will introduce you to vectors and functions such as sorting.\n\nIn Vectors, you will:\n\n-   Create numeric and character vectors.\n\n-   Name the columns of a vector.\n\n-   Generate numeric sequences.\n\n-   Access specific elements or parts of a vector.\n\n-   Coerce data into different data types as needed.\n\nIn Sorting, you will:\n\n-   Sort vectors in ascending and descending order.\n\n-   Extract the indices of the sorted elements from the original vector.\n\n-   Find the maximum and minimum elements, as well as their indices, in a vector.\n\n-   Rank the elements of a vector in increasing order.\n\nIn Vector Arithmetic, you will:\n\n-   Perform arithmetic between a vector and a single number.\n\n-   Perform arithmetic between two vectors of the same length.\n\n## Vectors\n\n### Key points\n\n-   The function c(), which stands for concatenate, is useful for creating vectors.\n\n-   Another useful function for creating vectors is the seq() function, which generates sequences.\n\n-   Subsetting lets us access specific parts of a vector by using square brackets to access elements of a vector.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We may create vectors of class numeric or character with the concatenate function\ncodes <- c(380, 124, 818)\ncountry <- c(\"italy\", \"canada\", \"egypt\")\n\n# We can also name the elements of a numeric vector\n# Note that the two lines of code below have the same result\ncodes <- c(italy = 380, canada = 124, egypt = 818)\ncodes <- c(\"italy\" = 380, \"canada\" = 124, \"egypt\" = 818)\n\n# We can also name the elements of a numeric vector using the names() function\ncodes <- c(380, 124, 818)\ncountry <- c(\"italy\",\"canada\",\"egypt\")\nnames(codes) <- country\n\n# Using square brackets is useful for subsetting to access specific elements of a vector\ncodes[2]\ncodes[c(1,3)]\ncodes[1:2]\n\n# If the entries of a vector are named, they may be accessed by referring to their name\ncodes[\"canada\"]\ncodes[c(\"egypt\",\"italy\")]\n```\n:::\n\n\n## Vector Coercion\n\n### Key Point\n\n-   In general, coercion is an attempt by R to be flexible with data types by guessing what was meant when an entry does not match the expected. For example, when defining x as\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    x <- c(1, \"canada\", 3)\n```\n:::\n\n\nR coerced the data into characters. It guessed that because you put a character string in the vector, you meant the 1 and 3 to actually be character strings, \"1\" and \"3\".\n\n-   The function `as.character()` turns numbers into characters.\n\n-   The function `as.numeric()` turns characters into numbers.\n\n-   In R, missing data is assigned the value `NA`.\n\n### Question\n\n1.  class(3L) is integer ?\n2.  3L-3 equals 0 ?\n\n## Sorting\n\n|          |                       |                                            |                                           |\n|--------------|--------------|----------------------|----------------------|\n| Original | Sort(按从小到大排列） | Order(Sort对应数字在原来数字排列中的顺序） | Rank(Original原来数字在Sort顺序中的排名） |\n| 31       | 4                     | 2                                          | 3                                         |\n| 4        | 15                    | 3                                          | 1                                         |\n| 15       | 31                    | 1                                          | 2                                         |\n| 92       | 65                    | 5                                          | 5                                         |\n| 65       | 92                    | 4                                          | 4                                         |\n\n### Key Points\n\n-   The function `sort()` sorts a vector in increasing order.\n\n-   The function `order()` produces the indices needed to obtain the sorted vector, e.g. a result of 2 3 1 5 4 means the sorted vector will be produced by listing the 2nd, 3rd, 1st, 5th, and then 4th item of the original vector.\n\n-   The function `rank()` gives us the ranks of the items in the original vector.\n\n-   The function `max()` returns the largest value, while `which.max()` returns the index of the largest value. The functions `min()` and `which.min()` work similarly for minimum values.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dslabs)\ndata(murders)\nsort(murders$total)\n\nx <- c(31, 4, 15, 92, 65)\nx\nsort(x)    # puts elements in order\n\nindex <- order(x)    # returns index that will put x in order\nx[index]    # rearranging by this index puts elements in order\norder(x)\n\nmurders$state[1:10]\nmurders$abb[1:10]\n\nindex <- order(murders$total)\nmurders$abb[index]    # order abbreviations by total murders\n\nmax(murders$total)    # highest number of total murders\ni_max <- which.max(murders$total)    # index with highest number of murders\nmurders$state[i_max]    # state name with highest number of total murders\n\nx <- c(31, 4, 15, 92, 65)\nx\nrank(x)    # returns ranks (smallest to largest)\n```\n:::\n\n\n## Vector Arithmetic\n\n### Key Point\n\n-   In R, arithmetic operation on vectors occur element-wise\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The name of the state with the maximum population is found by doing the following\nmurders$state[which.max(murders$population)]\n\n# how to obtain the murder rate\nmurder_rate <- murders$total / murders$population * 100000\n\n# ordering the states by murder rate, in decreasing order\nmurders$state[order(murder_rate, decreasing=TRUE)]\n```\n:::\n\n\n# Indexing, Data Wrangling, Plots\n\nIn this section, I will introduce the R commands and techniques that help you wrangle, analyze, and visualize data.\n\nIn Indexing, you will: - Subset a vector based on properties of another vector.\n\n-   Use multiple logical operators to index vectors.\n\n-   Extract the indices of vector elements satisfying one or more logical conditions.\n\n-   Extract the indices of vector elements matching with another vector.\n\n-   Determine which elements in one vector are present in another vector.\n\nIn basic data wrangling, you will:\n\n-   Wrangle data tables using functions in the dplyr package.\n\n-   Modify a data table by adding or changing columns.\n\n-   Subset rows in a data table.\n\n-   Subset columns in a data table.\n\n-   Perform a series of operations using the pipe operator.\n\n-   Create data frames.\n\nIn basic plots, you will: - Plot data in scatter plots, box plots, and histograms.\n\nIn summarizing with dplyr, you will: - Use summarize() to facilitate summarizing data in dplyr.\n\n-   Learn about the dot placeholder.\n\n-   Learn how to group and then summarize in dplyr.\n\n-   Learn how to sort data tables in dplyr.\n\nIn the rest section, you will: - Learn how to subset and summarize data using data.table.\n\n-   Learn how to sort data frames using data.table.\n\n## Indexing\n\n### Key Point\n\n-   We can use logicals to index vectors.\n\n-   Using the function sum()on a logical vector returns the number of entries that are true.\n\n-   The logical operator \"&\" makes two logicals true only when they are both true.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# defining murder rate as before\nmurder_rate <- murders$total / murders$population * 100000\n# creating a logical vector that specifies if the murder rate in that state is less than or equal to 0.71\nindex <- murder_rate <= 0.71\n# determining which states have murder rates less than or equal to 0.71\nmurders$state[index]\n# calculating how many states have a murder rate less than or equal to 0.71\nsum(index)\n\n# creating the two logical vectors representing our conditions\nwest <- murders$region == \"West\"\nsafe <- murder_rate <= 1\n# defining an index and identifying states with both conditions true\nindex <- safe & west\nmurders$state[index]\n```\n:::\n\n\n## Indexing Functions\n\n### Key Points\n\n-   The function `which()` gives us the entries of a logical vector that are true.\n\n-   The function `match()` looks for entries in a vector and returns the index needed to access them.\n\n-   We use the function `%in%` if we want to know whether or not each element of a first vector is in a second vector.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(FALSE, TRUE, FALSE, TRUE, TRUE, FALSE)\nwhich(x)    # returns indices that are TRUE\n\n# to determine the murder rate in Massachusetts we may do the following\nindex <- which(murders$state == \"Massachusetts\")\nindex\nmurder_rate[index]\n\n# to obtain the indices and subsequent murder rates of New York, Florida, Texas, we do:\nindex <- match(c(\"New York\", \"Florida\", \"Texas\"), murders$state)\nindex\nmurders$state[index]\nmurder_rate[index]\n\nx <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\ny <- c(\"a\", \"d\", \"f\")\ny %in% x\n\n# to see if Boston, Dakota, and Washington are states\nc(\"Boston\", \"Dakota\", \"Washington\") %in% murders$state\n```\n:::\n\n\n## Basic Data Wrangling\n\n### Key Points\n\n-   To change a data table by **adding a new column**, or changing an existing one, we use the `mutate()` function.\n\n-   To **filter the data** by subsetting rows, we use the function `filter()`.\n\n-   To subset the data by **selecting specific columns**, we use the `select()` function.\n\n-   We can perform a series of operations by sending the results of one function to another function using the **pipe operator**, `%>%`.\n\n## Creating Data Frames\n\n### Note\n\nThe default settings in R have changed as of version 4.0, and it is no longer necessary to include the code `stringsAsFactors = FALSE` in order to keep strings as characters. Putting the entries in quotes, as in the example, is adequate to keep strings as characters. The `stringsAsFactors = FALSE` code is useful in certain other situations, but you do not need to include it when you create data frames in this manner.\n\n### Key Points\n\n-   We can use the `data.frame()` function to create data frames.\n\n-   Formerly, the `data.frame()` function turned characters into factors by default. To avoid this, we could utilize the `stringsAsFactors` argument and set it equal to false. As of R 4.0, it is no longer necessary to include the `stringsAsFactors` argument, because R no longer turns characters into factors by default.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# creating a data frame with stringAsFactors = FALSE\ngrades <- data.frame(names = c(\"John\", \"Juan\", \"Jean\", \"Yao\"), \n                     exam_1 = c(95, 80, 90, 85), \n                     exam_2 = c(90, 85, 85, 90),\n                     stringsAsFactors = FALSE)\n```\n:::\n\n\n## Basic Plots\n\n### Key Points\n\n-   We can create a simple scatterplot using the function `plot()`.\n\n-   Histograms are graphical summaries that give you a general overview of the types of values you have. In R, they can be produced using the `hist()` function.\n\n-   Boxplots provide a more compact summary of a distribution than a histogram and are more useful for comparing distributions. They can be produced using the `boxplot()` function.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(dslabs)\ndata(\"murders\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# a simple scatterplot of total murders versus population\nx <- murders$population /10^6\ny <- murders$total\nplot(x, y)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# a histogram of murder rates\nmurders <- mutate(murders, rate = total / population * 100000)\nhist(murders$rate)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# boxplots of murder rates by region\nboxplot(rate~region, data = murders)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\n## The summarize function\n\n### Key Points\n\n-   Summarizing data is an important part of data analysis.\n\n-   Some summary ststistics are the **mean**, **median**, and **standard deviation**.\n\n-   The `summarize()` function from **dplyr** provides an easy way to compute summary statics.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(murders)\nmurders <- mutate(murders, rate = total / population * 10^5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# minimum, median, and maximum murder rate for the states in the West region\ns <- murders %>% \n  filter(region == \"West\") %>%\n  summarize(minimum = min(rate), \n            median = median(rate), \n            maximum = max(rate))\ns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   minimum   median  maximum\n1 0.514592 1.292453 3.629527\n```\n\n\n:::\n\n```{.r .cell-code}\n# accessing the components with the accessor $\ns$median\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.292453\n```\n\n\n:::\n\n```{.r .cell-code}\ns$maximum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.629527\n```\n\n\n:::\n\n```{.r .cell-code}\n# average rate unadjusted by population size\nmean(murders$rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.779125\n```\n\n\n:::\n\n```{.r .cell-code}\n# average rate adjusted by population size\nus_murder_rate <- murders %>% \n  summarize(rate = sum(total) / sum(population) * 10^5)\nus_murder_rate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      rate\n1 3.034555\n```\n\n\n:::\n:::\n\n\n## Summarizing with more than one value\n\n### Key Points\n\n-   The `quantile()` function can be used to return the min, median, and max in a single line of code.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(murders)\nmurders <- mutate(murders, rate = total / population * 10^5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# minimum, median, and maximum murder rate for the states in the West region using quantile\n# note that this returns a vector\nmurders %>% \n  filter(region == \"West\") %>%\n  summarize(range = quantile(rate, c(0, 0.5, 1)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     range\n1 0.514592\n2 1.292453\n3 3.629527\n```\n\n\n:::\n\n```{.r .cell-code}\n# returning minimum, median, and maximum as a data frame\nmy_quantile <- function(x){\n  r <-  quantile(x, c(0, 0.5, 1))\n  data.frame(minimum = r[1], median = r[2], maximum = r[3]) \n}\nmurders %>% \n  filter(region == \"West\") %>%\n  summarize(my_quantile(rate))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   minimum   median  maximum\n1 0.514592 1.292453 3.629527\n```\n\n\n:::\n:::\n\n\n## Pull to access to columns\n\n### Key Points\n\n-   The `pull()` function can be used to access values stored in data when using pipes: when a data object is piped that object and its columns can be accessed using the `pull()` function.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(murders)\nmurders <- mutate(murders, rate = total / population * 10^5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# average rate adjusted by population size\nus_murder_rate <- murders %>% \n  summarize(rate = sum(total) / sum(population) * 10^5)\nus_murder_rate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      rate\n1 3.034555\n```\n\n\n:::\n\n```{.r .cell-code}\n# us_murder_rate is stored as a data frame\nclass(us_murder_rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# the pull function can return it as a numeric value\nus_murder_rate %>% pull(rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.034555\n```\n\n\n:::\n\n```{.r .cell-code}\n# using pull to save the number directly\nus_murder_rate <- murders %>% \n  summarize(rate = sum(total) / sum(population) * 10^5) %>%\n  pull(rate)\nus_murder_rate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.034555\n```\n\n\n:::\n\n```{.r .cell-code}\n# us_murder_rate is now stored as a number\nclass(us_murder_rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n## The dot placeholder\n\n### Key Points\n\n-   The `dot (.)` can be thought of as a placeholder for the data being passed through the pipe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(murders)\nmurders <- mutate(murders, rate = total / population * 10^5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# average rate adjusted by population size\nus_murder_rate <- murders %>% \n  summarize(rate = sum(total) / sum(population) * 10^5)\nus_murder_rate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      rate\n1 3.034555\n```\n\n\n:::\n\n```{.r .cell-code}\n# using the dot to access the rate\nus_murder_rate <- murders %>% \n  summarize(rate = sum(total) / sum(population) * 10^5) %>%\n  .$rate\nus_murder_rate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.034555\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(us_murder_rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n## Group then summarize\n\n### Key Points\n\n-   Splitting data into groups and then computing summaries for each group is a common operation in data exploration.\n\n-   We can use the **dplyr** `group_by()` function to create a special grouped data frame to facilitate such summaries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(murders)\nmurders <- mutate(murders, rate = total / population * 10^5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# group by region\nmurders %>% group_by(region)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 × 6\n# Groups:   region [4]\n   state                abb   region    population total  rate\n   <chr>                <chr> <fct>          <dbl> <dbl> <dbl>\n 1 Alabama              AL    South        4779736   135  2.82\n 2 Alaska               AK    West          710231    19  2.68\n 3 Arizona              AZ    West         6392017   232  3.63\n 4 Arkansas             AR    South        2915918    93  3.19\n 5 California           CA    West        37253956  1257  3.37\n 6 Colorado             CO    West         5029196    65  1.29\n 7 Connecticut          CT    Northeast    3574097    97  2.71\n 8 Delaware             DE    South         897934    38  4.23\n 9 District of Columbia DC    South         601723    99 16.5 \n10 Florida              FL    South       19687653   669  3.40\n# ℹ 41 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# summarize after grouping\nmurders %>% \n  group_by(region) %>%\n  summarize(median = median(rate))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  region        median\n  <fct>          <dbl>\n1 Northeast       1.80\n2 South           3.40\n3 North Central   1.97\n4 West            1.29\n```\n\n\n:::\n:::\n\n\n## Sorting data tables\n\n### Key Points\n\n-   To order an entire table, we can use the **dplyr** function `arrange()`.\n\n-   We can also use nested sorting to order by additional columns.\n\n-   The function `head()` returns on the first few lines of a table.\n\n-   The function `top_n()` returns the top n rows of a table.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(murders)\nmurders <- mutate(murders, rate = total / population * 10^5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# order the states by population size\nmurders %>% arrange(population) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 state abb        region population total       rate\n1              Wyoming  WY          West     563626     5  0.8871131\n2 District of Columbia  DC         South     601723    99 16.4527532\n3              Vermont  VT     Northeast     625741     2  0.3196211\n4         North Dakota  ND North Central     672591     4  0.5947151\n5               Alaska  AK          West     710231    19  2.6751860\n6         South Dakota  SD North Central     814180     8  0.9825837\n```\n\n\n:::\n\n```{.r .cell-code}\n# order the states by murder rate - the default is ascending order\nmurders %>% arrange(rate) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          state abb        region population total      rate\n1       Vermont  VT     Northeast     625741     2 0.3196211\n2 New Hampshire  NH     Northeast    1316470     5 0.3798036\n3        Hawaii  HI          West    1360301     7 0.5145920\n4  North Dakota  ND North Central     672591     4 0.5947151\n5          Iowa  IA North Central    3046355    21 0.6893484\n6         Idaho  ID          West    1567582    12 0.7655102\n```\n\n\n:::\n\n```{.r .cell-code}\n# order the states by murder rate in descending order\nmurders %>% arrange(desc(rate)) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 state abb        region population total      rate\n1 District of Columbia  DC         South     601723    99 16.452753\n2            Louisiana  LA         South    4533372   351  7.742581\n3             Missouri  MO North Central    5988927   321  5.359892\n4             Maryland  MD         South    5773552   293  5.074866\n5       South Carolina  SC         South    4625364   207  4.475323\n6             Delaware  DE         South     897934    38  4.231937\n```\n\n\n:::\n\n```{.r .cell-code}\n# order the states by region and then by murder rate within region\nmurders %>% arrange(region, rate) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          state abb    region population total      rate\n1       Vermont  VT Northeast     625741     2 0.3196211\n2 New Hampshire  NH Northeast    1316470     5 0.3798036\n3         Maine  ME Northeast    1328361    11 0.8280881\n4  Rhode Island  RI Northeast    1052567    16 1.5200933\n5 Massachusetts  MA Northeast    6547629   118 1.8021791\n6      New York  NY Northeast   19378102   517 2.6679599\n```\n\n\n:::\n\n```{.r .cell-code}\n# return the top 10 states by murder rate\nmurders %>% top_n(10, rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  state abb        region population total      rate\n1               Arizona  AZ          West    6392017   232  3.629527\n2              Delaware  DE         South     897934    38  4.231937\n3  District of Columbia  DC         South     601723    99 16.452753\n4               Georgia  GA         South    9920000   376  3.790323\n5             Louisiana  LA         South    4533372   351  7.742581\n6              Maryland  MD         South    5773552   293  5.074866\n7              Michigan  MI North Central    9883640   413  4.178622\n8           Mississippi  MS         South    2967297   120  4.044085\n9              Missouri  MO North Central    5988927   321  5.359892\n10       South Carolina  SC         South    4625364   207  4.475323\n```\n\n\n:::\n\n```{.r .cell-code}\n# return the top 10 states ranked by murder rate, sorted by murder rate\nmurders %>% arrange(desc(rate)) %>% top_n(10)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSelecting by rate\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  state abb        region population total      rate\n1  District of Columbia  DC         South     601723    99 16.452753\n2             Louisiana  LA         South    4533372   351  7.742581\n3              Missouri  MO North Central    5988927   321  5.359892\n4              Maryland  MD         South    5773552   293  5.074866\n5        South Carolina  SC         South    4625364   207  4.475323\n6              Delaware  DE         South     897934    38  4.231937\n7              Michigan  MI North Central    9883640   413  4.178622\n8           Mississippi  MS         South    2967297   120  4.044085\n9               Georgia  GA         South    9920000   376  3.790323\n10              Arizona  AZ          West    6392017   232  3.629527\n```\n\n\n:::\n:::\n\n\n## Introduction to data.table\n\n### Key Points\n\n-   In this course, we often use tidyverse packages to illustrate because these packages tend to have code that is very readable for beginners.\n\n-   There are other approaches to wrangling and analyzing data in R that are faster and better at handling large objects, such as the data.table package.\n\n-   Selecting in data.table uses notation similar to that used with matrices.\n\n-   To add a column in data.table, you can use the := function.\n\n-   Because the data.table package is designed to avoid wasting memory, when you make a copy of a table, it does not create a new object. The := function changes by reference. If you want to make an actual copy, you need to use the copy() function.\n\n-   Side note: the R language has a new, built-in pipe operator as of version 4.1: \\|\\>. This works similarly to the pipe %\\>% you are already familiar with. You can [read more about the \\|\\> pipe here External link](https://www.r-bloggers.com/2021/05/the-new-r-pipe/).\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install the data.table package before you use it!\ninstall.packages(\"data.table\")\n\n# load data.table package\nlibrary(data.table)\n\n# load other packages and datasets\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(murders)\n\n# convert the data frame into a data.table object\nmurders <- setDT(murders)\n\n# selecting in dplyr\nselect(murders, state, region)\n\n# selecting in data.table - 2 methods\nmurders[, c(\"state\", \"region\")] |> head()\nmurders[, .(state, region)] |> head()\n\n# adding or changing a column in dplyr\nmurders <- mutate(murders, rate = total / population * 10^5)\n\n# adding or changing a column in data.table\nmurders[, rate := total / population * 100000]\nhead(murders)\nmurders[, \":=\"(rate = total / population * 100000, rank = rank(population))]\n\n# y is referring to x and := changes by reference\nx <- data.table(a = 1)\ny <- x\n\nx[,a := 2]\ny\n\ny[,a := 1]\nx\n\n# use copy to make an actual copy\nx <- data.table(a = 1)\ny <- copy(x)\nx[,a := 2]\ny\n```\n:::\n\n\n## Subsetting with data.table\n\n### Key Points\n\n[Subsetting in **data.table**](http://rafalab.dfci.harvard.edu/dsbook/data-table.html#subsetting-1) uses notation similar to that used with matrices.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages and prepare the data\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(murders)\nlibrary(data.table)\nmurders <- setDT(murders)\nmurders <- mutate(murders, rate = total / population * 10^5)\nmurders[, rate := total / population * 100000]\n\n# subsetting in dplyr\nfilter(murders, rate <= 0.7)\n\n# subsetting in data.table\nmurders[rate <= 0.7]\n\n# combining filter and select in data.table\nmurders[rate <= 0.7, .(state, rate)]\n\n# combining filter and select in dplyr\nmurders %>% filter(rate <= 0.7) %>% select(state, rate)\n```\n:::\n\n\n## Summarizing with data.table\n\n### Key Points\n\n-   In data.table we can call functions inside `.()`and they will be applied to rows.\n\n-   The `group_by` followed by summarize in **dplyr** is performed in one line in data.table using the by argument.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages and prepare the data - heights dataset\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(dslabs)\ndata(heights)\nheights <- setDT(heights)\n\n# summarizing in dplyr\ns <- heights %>% \n  summarize(average = mean(height), standard_deviation = sd(height))\n  \n# summarizing in data.table\ns <- heights[, .(average = mean(height), standard_deviation = sd(height))]\n\n# subsetting and then summarizing in dplyr\ns <- heights %>% \n  filter(sex == \"Female\") %>%\n  summarize(average = mean(height), standard_deviation = sd(height))\n  \n# subsetting and then summarizing in data.table\ns <- heights[sex == \"Female\", .(average = mean(height), standard_deviation = sd(height))]\n\n# previously defined function\nmedian_min_max <- function(x){\n  qs <- quantile(x, c(0.5, 0, 1))\n  data.frame(median = qs[1], minimum = qs[2], maximum = qs[3])\n}\n\n# multiple summaries in data.table\nheights[, .(median_min_max(height))]\n\n# grouping then summarizing in data.table\nheights[, .(average = mean(height), standard_deviation = sd(height)), by = sex]\n```\n:::\n\n\n## [Sorting data frames](http://rafalab.dfci.harvard.edu/dsbook/tidyverse.html#sorting-data-frames)\n\n### Key Points\n\n-   To order rows in a data frame using data.table, we can use the same approach we used for filtering.\n\n-   The default sort is an ascending order, but we can also sort tables in descending order.\n\n-   We can also perform nested sorting by including multiple variables in the desired sort order.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages and datasets and prepare the data\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(data.table)\nlibrary(dslabs)\ndata(murders)\nmurders <- setDT(murders)\nmurders[, rate := total / population * 100000]\n\n# order by population\nmurders[order(population)] |> head()\n\n# order by population in descending order\nmurders[order(population, decreasing = TRUE)] \n\n# order by region and then murder rate\nmurders[order(region, rate)]\n```\n:::\n\n\n# Programming Basics\n\nIn this section, I will introduce you to general programming features like 'if-else' and 'for loop' commands so that you can write your own functions to perform various operations on datasets.\n\nIn programming basics, you will: - Understand some of the programming capabilities of R.\n\nIn basic condationals, you will: - Use basic conditional expressions to perform different operations. Check if any or all elements of a logical vector are TRUE.\n\nIn function, you will: - Define and call functions to perform various operations.\n\n-   Pass arguments to functions, and return variables/objects from functions.\n\nIn loops, you will: - Use for-loops to perform repeated operations.\n\n-   Articulate in-built functions of R that you could try for yourself.\n\n## Programming Basics\n\n[Introduction to Programming in R](http://rafalab.dfci.harvard.edu/dsbook/programming-basics.html)\n\n## Basic Condationals\n\n### Key Points\n\n-   The most common conditional expression in programming is an if-else statement, which has the form \"if \\[condition\\], perform \\[expression\\], else perform \\[alternative expression\\]\".\n\n-   The `ifelse()` function works similarly to an if-else statement, but it is particularly useful since it works on vectors by examining each element of the vector and returning a corresponding answer accordingly.\n\n-   The `any()` function takes a vector of logicals and returns true if any of the entries are true.\n\n-   The `all()` function takes a vector of logicals and returns true if all of the entries are true.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# an example showing the general structure of an if-else statement\na <- 0\nif(a!=0){\n  print(1/a)\n} else{\n  print(\"No reciprocal for 0.\")\n}\n\n# an example that tells us which states, if any, have a murder rate less than 0.5\nlibrary(dslabs)\ndata(murders)\nmurder_rate <- murders$total / murders$population*100000\nind <- which.min(murder_rate)\nif(murder_rate[ind] < 0.5){\n  print(murders$state[ind]) \n} else{\n  print(\"No state has murder rate that low\")\n}\n\n# changing the condition to < 0.25 changes the result\nif(murder_rate[ind] < 0.25){\n  print(murders$state[ind]) \n} else{\n  print(\"No state has a murder rate that low.\")\n}\n\n# the ifelse() function works similarly to an if-else conditional\na <- 0\nifelse(a > 0, 1/a, NA)\n\n# the ifelse() function is particularly useful on vectors\na <- c(0,1,2,-4,5)\nresult <- ifelse(a > 0, 1/a, NA)\n\n# the ifelse() function is also helpful for replacing missing values\ndata(na_example)\nno_nas <- ifelse(is.na(na_example), 0, na_example) \nsum(is.na(no_nas))\n\n# the any() and all() functions evaluate logical vectors\nz <- c(TRUE, TRUE, FALSE)\nany(z)\nall(z)\n```\n:::\n\n\n## Functions\n\n### Key Points\n\n-   The R function called function() tells R you are about to define a new function.\n\n-   Functions are objects, so must be assigned a variable name with the arrow operator.\n\n-   The general way to define functions is:\n\n    -   \n\n        (1) decide the function name, which will be an object,\n\n    -   \n\n        (2) type function() with your function's arguments in parentheses, - (3) write all the operations inside brackets.\n\n-   Variables defined inside a function are not saved in the workspace.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# example of defining a function to compute the average of a vector x\navg <- function(x){\n  s <- sum(x)\n  n <- length(x)\n  s/n\n}\n\n# we see that the above function and the pre-built R mean() function are identical\nx <- 1:100\nidentical(mean(x), avg(x))\n\n# variables inside a function are not defined in the workspace\ns <- 3\navg(1:10)\ns\n\n# the general form of a function\nmy_function <- function(VARIABLE_NAME){\n  perform operations on VARIABLE_NAME and calculate VALUE\n  VALUE\n}\n\n# functions can have multiple arguments as well as default values\navg <- function(x, arithmetic = TRUE){\n  n <- length(x)\n  ifelse(arithmetic, sum(x)/n, prod(x)^(1/n))\n}\n```\n:::\n\n\n## For Loops\n\n### Key Points\n\n-   For-loops perform the same task over and over while changing the variable. They let us define the range that our variable takes, and then changes the value with each loop and evaluates the expression every time inside the loop.\n\n-   The general form of a for-loop is: \"For i in \\[some range\\], do operations\". This i changes across the range of values and the operations assume i is a value you're interested in computing on.\n\n-   At the end of the loop, the value of i is the last value of the range.\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# creating a function that computes the sum of integers 1 through n\ncompute_s_n <- function(n){\n  x <- 1:n\n  sum(x)\n}\n\n# a very simple for-loop\nfor(i in 1:5){\n  print(i)\n}\n\n# a for-loop for our summation\nm <- 25\ns_n <- vector(length = m) # create an empty vector\nfor(n in 1:m){\n  s_n[n] <- compute_s_n(n)\n}\n\n# creating a plot for our summation function\nn <- 1:m\nplot(n, s_n)\n\n# a table of values comparing our function to the summation formula\nhead(data.frame(s_n = s_n, formula = n*(n+1)/2))\n\n# overlaying our function with the summation formula\nplot(n, s_n)\nlines(n, n*(n+1)/2)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}