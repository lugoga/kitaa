[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "DATIKA",
    "section": "",
    "text": "Data Visualization\n\n\n\n\n\n\nData Science\n\n\nData Visualization\n\n\n\nData Science-Data Visualization\n\n\n\n\n\nMay 5, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nData cleaning, merging, and appending\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nMay 1, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nTidying Data frame\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nApr 29, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding Descriptive Statistics\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\nStatistics\n\n\n\nExamine measures of center and dispersion of the data so that we can gain valuable insights into the characteristics and distribution of various metrics that are in a dataset\n\n\n\n\n\nApr 25, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nBasic plots with ggplot2\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nApr 1, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nVisualizing data with grammar of graphics\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nMar 25, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nImporting table files into R\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\n\nLearning to import tabular files from local directory intot R session is an important skills in R programming\n\n\n\n\n\nFeb 26, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding vector and dataframe\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\n\nUnderstanding vectoor and dataframe as core data storage in R is an important part, which allows for data analysis and visualization\n\n\n\n\n\nFeb 12, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nMastering Data Structures in R\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\n\nLearn the primary data structures (vector and data frame) in R, which are the foundation of data manipulation and analysis in R \n\n\n\n\n\nFeb 3, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding and using Data types in R\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\n\nLearn the primary data types in R, which are the foundation of data programming in R \n\n\n\n\n\nJan 26, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started with R and RStudio\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\n\nLearn the basic of programming with R using RStudio. We’ll install R, and RStudio RStudio, an extremely popular development environment for R \n\n\n\n\n\nJan 24, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nThe basics of R programming\n\n\n\n\n\n\nData Science\n\n\nR Basic\n\n\n\nData Science-R Basic\n\n\n\n\n\nJan 24, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nThe basics of R and Rstudio\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\nanalysis\n\n\n\nUnderstanding the building blocks of R and its working environment Rstudio for smooth operations in data science\n\n\n\n\n\nJan 24, 2024\n\n\nMasumbuko Semba\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a Timeline graphic using R and ggplot2\n\n\n\n\n\n\nvisualization\n\n\ncode\n\n\nanalysis\n\n\n\nCreating a timeline graphic using ggplot2, which is a powerful data visualization library in R\n\n\n\n\n\nNov 24, 2023\n\n\nMasumbuko Semba\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/vectorDataframe/index.html",
    "href": "posts/vectorDataframe/index.html",
    "title": "Understanding vector and dataframe",
    "section": "",
    "text": "R language is a flexible language that allows to work with different kind of data format (R Core Team, 2023). This include integer, numeric, character, complex, dates and logical. The default data type or class in R is double precision– numeric. In a nutshell, R treats all kind of data into five categories but we deal with only four in this book. Datasets in R are often a combination of seven different data types are highlighted in Figure 1;\n\n\n\n\n\n\nFigure 1: Common data types often collected and stored for anaysis and modelling"
  },
  {
    "objectID": "posts/vectorDataframe/index.html#numeric",
    "href": "posts/vectorDataframe/index.html#numeric",
    "title": "Understanding vector and dataframe",
    "section": "Numeric",
    "text": "Numeric\nThe most common data type in R is numeric. The numeric class holds the set of real numbers — decimal place numbers. We create a numeric vector using a c() function but you can use any function that creates a sequence of numbers. For example, we can create a numeric vector of SST as follows;\n\nsst = c(25.4, 26, 28, 27.8, 29, 24.8, 22.3)\n\nWe can check whether the variable sst is numeric with is.numeric function\n\nis.numeric(sst)\n\n[1] TRUE"
  },
  {
    "objectID": "posts/vectorDataframe/index.html#integer",
    "href": "posts/vectorDataframe/index.html#integer",
    "title": "Understanding vector and dataframe",
    "section": "Integer",
    "text": "Integer\nInteger vector data type is actually a special case of numeric data. Unlike numeric, integer values do not have decimal places.They are commonly used for counting or indexing. Creating an integer vector is similar to numeric vector except that we need to instruct R to treat the data as integer and not numeric or double. To command R creating integer, we specify a suffix L to an element\n\ndepth = c(5L, 10L, 15L, 20L, 25L,30L)\nis.vector(depth);class(depth)\n\n[1] TRUE\n\n\n[1] \"integer\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nif your variable does not have decimals, R will automatically set the type as integers instead of numeric.\n\n\n\naa = c(20,68,78,50)\n\nYou can check if the data is integer with is.integer() and can convert numeric value to an integer with as.integer()\n\nis.integer(aa)\n\n[1] FALSE\n\n\nYou can query the class of the object with the class() to know the class of the object\n\nclass(aa)\n\n[1] \"numeric\"\n\n\nAlthough the object bb is integer as confirmed with as.integer() function, the class() ouput the answer as numeric. This is because the defaul type of number in r is numeric. However, you can use the function as.integer() to convert numeric value to integer\n\nclass(as.integer(aa))\n\n[1] \"integer\""
  },
  {
    "objectID": "posts/vectorDataframe/index.html#character",
    "href": "posts/vectorDataframe/index.html#character",
    "title": "Understanding vector and dataframe",
    "section": "Character",
    "text": "Character\nIn programming terms, we usually call text as string. This often are text data like names. A character vector may contain a single character , a word or a group of words. The elements must be enclosed with a single or double quotations mark.\n\nsites = c(\"Pemba Channel\", \"Zanzibar Channnel\", \"Pemba Channel\")\nis.vector(sites); class(sites)\n\n[1] TRUE\n\n\n[1] \"character\"\n\n\nWe can be sure whether the object is a string with is.character() or check the class of the object with class().\n\ncountries = c(\"Kenya\", \"Uganda\", \"Rwanda\", \"Tanzania\")\nclass(countries)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nEverything inside \"\" will be considered as character, no matter if it looks like character or not"
  },
  {
    "objectID": "posts/vectorDataframe/index.html#factor",
    "href": "posts/vectorDataframe/index.html#factor",
    "title": "Understanding vector and dataframe",
    "section": "Factor",
    "text": "Factor\nFactor variables are a special case of character variables in the sense that it also contains text. However, factor variables are used when there are a limited number of unique character strings. It often represents a categorical variable. For instance, the gender will usually take on only two values, \"female\" or \"male\" (and will be considered as a factor variable) whereas the name will generally have lots of possibilities (and thus will be considered as a character variable). To create a factor variable use the factor() function:\n\n    maturity.stage &lt;- factor(c(\"I\", \"II\", \"III\", \"IV\", \"V\"))\n    maturity.stage\n\n[1] I   II  III IV  V  \nLevels: I II III IV V\n\n\nTo know the different levels of a factor variable, use levels():\n\n levels(maturity.stage)\n\n[1] \"I\"   \"II\"  \"III\" \"IV\"  \"V\"  \n\n\nBy default, the levels are sorted alphabetically. You can reorder the levels with the argument levels in the factor() function:\n\nmature &lt;- factor(maturity.stage, levels = c(\"V\", \"III\"))\n    levels(mature)\n\n[1] \"V\"   \"III\"\n\n\nCharacter strings can be converted to factors with as.factor():\n\n text &lt;- c(\"test1\", \"test2\", \"test1\", \"test1\") # create a character vector\n    class(text) # to know the class\n\n[1] \"character\"\n\n\n\n text_factor &lt;- as.factor(text) # transform to factor\n    class(text_factor) # recheck the class\n\n[1] \"factor\"\n\n\nThe character strings have been transformed to factors, as shown by its class of the type factor.\nOften we wish to take a continuous numerical vector and transform it into a factor. The function cut() takes a vector of numerical data and creates a factor based on your give cut-points. Let us make a fictional total length of 508 bigeye tuna with rnorm() function.\n\ntl.cm = rnorm(n = 508, mean = 40, sd = 18)\n\n# mosaic::plotDist(dist = \"norm\", mean = 40, sd = 18, under = F, kind = \"cdf\", add = TRUE)\n\ntl.cm |&gt;\n  tibble::as.tibble() |&gt;\n  ggstatsplot::gghistostats(x = value, binwidth = 10, test.value = 40.2, type = \"n\", normal.curve = T, centrality.type = \"p\", xlab = \"Total length (cm)\")\n\n\n\n\n\n\n\nFigure 2: Normal distribution of bigeye tuna’s tota length\n\n\n\n\n\nWe can now breaks the distribution into groups and make a simple plot as shown in ?@fig-lfq, where frequency of bigeye tuna color coded with the group size\n\ngroup = cut(tl.cm, breaks = c(0,30,60,110),\n            labels = c(\"Below 20\", \"30-60\", \"Above 60\"))\nis.factor(group)\n\n[1] TRUE\n\nlevels(group)\n\n[1] \"Below 20\" \"30-60\"    \"Above 60\"\n\n\n\nbarplot(table(group), las = 1, horiz = FALSE, col = c(\"blue\", \"green\", \"red\"), ylab = \"Frequency\", xlab = \"\")\n\n\n\n\n\n\n\nFigure 3: Length frequency of bigeye tuna"
  },
  {
    "objectID": "posts/vectorDataframe/index.html#logical",
    "href": "posts/vectorDataframe/index.html#logical",
    "title": "Understanding vector and dataframe",
    "section": "Logical",
    "text": "Logical\nLogical data (or simply logical ) represent the logical TRUE state and the logical FALSE state. Logical variables are the variables in which logical data are stored. Logical variables can assume only two states:\n\nFALSE, always represent by 0;\nTRUE, always represented by a nonzero object. Usually, the digit 1 is used for TRUE.\n\nWe can create logical variables indirectly, through logical operations, such as the result of a comparison between two numbers. These operations return logical values. For example, type the following statement at the R console:\n\n5 &gt; 3;\n\n[1] TRUE\n\n5 &lt; 3\n\n[1] FALSE\n\n\nSince 5 is indeed greater than 3, the result of the comparison is true, however, 5 is not less than 3, and hence the comparison is false. The sign &gt; and &lt; are relational operators, returning logical data types as a result.\n\n value1 &lt;- 7\n    value2 &lt;- 9\n\n\n    greater &lt;- value1 &gt; value2\n    greater\n\n[1] FALSE\n\n    class(greater)\n\n[1] \"logical\"\n\n\n\n    # is value1 less than or equal to value2?\n    less &lt;- value1 &lt;= value2\n    less\n\n[1] TRUE\n\n    class(less)\n\n[1] \"logical\"\n\n\nIt is also possible to transform logical data into numeric data. After the transformation from logical to numeric with the as.numeric() command, FALSE values equal to 0 and TRUE values equal to 1:\n\n greater_num &lt;- as.numeric(greater)\n    sum(greater)\n\n[1] 0\n\n\n\n   less_num &lt;- as.numeric(less)\n    sum(less)\n\n[1] 1\n\n\nConversely, numeric data can be converted to logical data, with FALSE for all values equal to 0 and TRUE for all other values.\n\n  x &lt;- 0\n  as.logical(x)\n\n[1] FALSE\n\n\n\n y &lt;- 5\nas.logical(y)\n\n[1] TRUE"
  },
  {
    "objectID": "posts/vectorDataframe/index.html#date-and-time",
    "href": "posts/vectorDataframe/index.html#date-and-time",
    "title": "Understanding vector and dataframe",
    "section": "Date and Time",
    "text": "Date and Time\nDate and time are also treated as vector in R\n\ndate.time = seq(lubridate::dmy(010121), \n                lubridate::dmy(250121), \n                length.out = 5)\ndate.time\n\n[1] \"2021-01-01\" \"2021-01-07\" \"2021-01-13\" \"2021-01-19\" \"2021-01-25\""
  },
  {
    "objectID": "posts/vectorDataframe/index.html#sequence-numbers",
    "href": "posts/vectorDataframe/index.html#sequence-numbers",
    "title": "Understanding vector and dataframe",
    "section": "Sequence Numbers",
    "text": "Sequence Numbers\nThere are few R operators that are designed for creating vecor of non-random numbers. These functions provide multiple ways for generating sequences of numbers\nThe colon : operator, explicitly generate regular sequence of numbers between the lower and upper boundary numbers specified. For example, generating number beween 0 and 10, we simply write;\n\nvector.seq = 0:10\nvector.seq\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\nHowever, if you want to generate a vector of sequence number with specified interval, let say we want to generate number between 0 and 10 with interval of 2, then the seq() function is used\n\nregular.vector = seq(from = 0,to = 10, by = 2)\nregular.vector\n\n[1]  0  2  4  6  8 10\n\n\nunlike the seq() function and : operator that works with numbers, the rep() function generate sequence of repeated numbers or strings to create a vector\n\nid = rep(x = 3, each = 4)\nstation = rep(x = \"Station1\", each = 4)\nid;station\n\n[1] 3 3 3 3\n\n\n[1] \"Station1\" \"Station1\" \"Station1\" \"Station1\""
  },
  {
    "objectID": "posts/vectorDataframe/index.html#sequence-characters",
    "href": "posts/vectorDataframe/index.html#sequence-characters",
    "title": "Understanding vector and dataframe",
    "section": "Sequence characters",
    "text": "Sequence characters\nThe rep() function allows to parse each and times arguments. The each argument allows creation of vector that that repeat each element in a vector according to specified number.\n\nsampled.months = c(\"January\", \"March\", \"May\")\nrep(x = sampled.months, each = 3)\n\n[1] \"January\" \"January\" \"January\" \"March\"   \"March\"   \"March\"   \"May\"    \n[8] \"May\"     \"May\"    \n\n\nBut the times argument repeat the whole vector to specfied times\n\nrep(x = sampled.months, times = 3)\n\n[1] \"January\" \"March\"   \"May\"     \"January\" \"March\"   \"May\"     \"January\"\n[8] \"March\"   \"May\""
  },
  {
    "objectID": "posts/vectorDataframe/index.html#generating-normal-distribution",
    "href": "posts/vectorDataframe/index.html#generating-normal-distribution",
    "title": "Understanding vector and dataframe",
    "section": "Generating normal distribution",
    "text": "Generating normal distribution\nThe central limit theorem that ensure the data is normal distributed is well known to statistician. R has a rnorm() function which makes vector of normal distributed values. For example to generate a vector of 40 sea surface temperature values from a normal distribution with a mean of 25, and standard deviation of 1.58, we simply type this expression in console;\n\nsst = rnorm(n = 40, mean = 25,sd = 1.58)\nsst\n\n [1] 23.04693 24.99349 25.68869 23.84683 25.69666 24.93500 23.44773 26.62016\n [9] 27.67181 26.30010 22.03781 25.77229 23.92286 23.35629 27.66600 28.08170\n[17] 22.16890 24.93247 24.46477 25.94592 24.50469 28.61894 21.42219 26.88232\n[25] 26.96524 22.87907 26.34715 22.76567 24.19697 25.49118 29.21119 22.55112\n[33] 23.87877 25.75880 24.54350 23.59964 22.44975 25.43948 25.33276 23.46390"
  },
  {
    "objectID": "posts/vectorDataframe/index.html#rounding-off-numbers",
    "href": "posts/vectorDataframe/index.html#rounding-off-numbers",
    "title": "Understanding vector and dataframe",
    "section": "Rounding off numbers",
    "text": "Rounding off numbers\nThere are many ways of rounding off numerical number to the nearest integers or specify the number of decimal places. the code block below illustrate the common way to round off:\n\nchl = rnorm(n = 20, mean = .55, sd = .2)\nchl |&gt; round(digits = 2)\n\n [1] 0.32 0.74 0.58 0.31 0.59 0.85 0.76 0.53 0.32 0.72 0.63 0.38 0.47 0.52 0.98\n[16] 0.77 0.87 0.73 0.48 0.53"
  },
  {
    "objectID": "posts/vectorDataframe/index.html#number-of-elements-in-a-vector",
    "href": "posts/vectorDataframe/index.html#number-of-elements-in-a-vector",
    "title": "Understanding vector and dataframe",
    "section": "Number of elements in a vector",
    "text": "Number of elements in a vector\nSometimes you may have a long vector and want to know the numbers of elements in the object. R has length() function that allows you to query the vector and print the answer\n\nlength(chl)\n\n[1] 20"
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Archive",
    "section": "",
    "text": "Data Visualization\n\n\n\n\n\n\n\n\nMay 5, 2024\n\n\n\n\n\n\n\nData cleaning, merging, and appending\n\n\n\n\n\n\n\n\nMay 1, 2024\n\n\n\n\n\n\n\nTidying Data frame\n\n\n\n\n\n\n\n\nApr 29, 2024\n\n\n\n\n\n\n\nUnderstanding Descriptive Statistics\n\n\n\n\n\n\n\n\nApr 25, 2024\n\n\n\n\n\n\n\nBasic plots with ggplot2\n\n\n\n\n\n\n\n\nApr 1, 2024\n\n\n\n\n\n\n\nVisualizing data with grammar of graphics\n\n\n\n\n\n\n\n\nMar 25, 2024\n\n\n\n\n\n\n\nImporting table files into R\n\n\n\n\n\n\n\n\nFeb 26, 2024\n\n\n\n\n\n\n\nUnderstanding vector and dataframe\n\n\n\n\n\n\n\n\nFeb 12, 2024\n\n\n\n\n\n\n\nMastering Data Structures in R\n\n\n\n\n\n\n\n\nFeb 3, 2024\n\n\n\n\n\n\n\nUnderstanding and using Data types in R\n\n\n\n\n\n\n\n\nJan 26, 2024\n\n\n\n\n\n\n\nGetting Started with R and RStudio\n\n\n\n\n\n\n\n\nJan 24, 2024\n\n\n\n\n\n\n\nThe basics of R programming\n\n\n\n\n\n\n\n\nJan 24, 2024\n\n\n\n\n\n\n\nThe basics of R and Rstudio\n\n\n\n\n\n\n\n\nJan 24, 2024\n\n\n\n\n\n\n\nCreating a Timeline graphic using R and ggplot2\n\n\n\n\n\n\n\n\nNov 24, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "terms.html",
    "href": "terms.html",
    "title": "DATIKA",
    "section": "",
    "text": "66666"
  },
  {
    "objectID": "slides.html",
    "href": "slides.html",
    "title": "Agenda and Presentations for covered topics",
    "section": "",
    "text": "Our Agenda\n\nAn introduction\nGet familiar with R and Rstudio\nData types\nData structures\nReading and writing data in Rstudio\nTidying Data with tidyverse\nPlotting\n\nPlotting and Visualization_A\nPlotting and Visualization_B\nPlotting and Visualization_C\n\nData Manipulation\nDescriptive Statistics\nInferential Statistics\nModelling and simulation\nSpatial Handling and Analysis\nFurther topics\n\nGIt and Github\nReproducibility with Quarto\nWebsites and blog\nUsing python from Rstudio\nGenerating HTML, PDF and Word Reports"
  },
  {
    "objectID": "posts/dataTypes/index.html",
    "href": "posts/dataTypes/index.html",
    "title": "Understanding and using Data types in R",
    "section": "",
    "text": "In the realm of data science and statistical analysis, mastering data types is akin to understanding the building blocks of a language. In R, a powerful statistical computing language, data types form the foundation upon which all analyses are conducted. From integers to dates, each data type serves a unique purpose and understanding their nuances is critical for efficient and accurate data manipulation.\nUnderstanding and effectively utilizing these core data types in R is essential for performing data analysis, visualization, and modeling tasks. Mastery of data types empowers data scientists to manipulate data efficiently and extract valuable insights from complex datasets. Whether performing arithmetic operations, manipulating text, or handling temporal information, the versatility of R’s data types makes it a powerful tool for data analysis and statistical computing.\nIn this guide, we will delve into the core data types in R, exploring their characteristics and providing illustrative examples. Before we dive in, let pause for a moment and watch video in Figure 1\n\n\n\n\n\n\nFigure 1: Primary data types in R\n\n\n\n\n\nIntegers are whole numbers without any decimal or fractional component. In R, integers are represented by the integer class. They are commonly used for indexing and counting operations.\n\nExample 1  \n# Creating an integer variable\nx &lt;- 5L\nclass(x) # Output: \"integer\"\n\n# Arithmetic operations with integers\ny &lt;- x + 3\n\n\n\n\nNumeric data type, also known as double in other programming languages, represents numbers with decimal points. Numeric data types are used for most mathematical calculations and statistical operations in R.\n\nExample 2  \n# Creating a numeric variable\nheight &lt;- 175.5\nclass(height) # Output: \"numeric\"\n\n# Arithmetic operations with numeric variables\nbmi &lt;- weight / (height^2)\n\n\n\n\nCharacter data type represents textual data such as strings of letters, words, or sentences. In R, character values are enclosed in either single or double quotes.\n\nExample 3  \n# Creating a character variable\nname &lt;- \"John Doe\"\nclass(name) # Output: \"character\"\n\n# Concatenating character strings\ngreeting &lt;- paste(\"Hello\", name)\n\n\n\n\nLogical data type, often referred to as Boolean, represents binary values: TRUE or FALSE. Logical values are fundamental in controlling program flow and making decisions based on conditions.\n\nExample 4  \n# Creating logical variables\nis_adult &lt;- TRUE\nclass(is_adult) # Output: \"logical\"\n\n# Conditional statements with logical variables\nif (is_adult) {\n  print(\"You are an adult.\")\n} else {\n  print(\"You are not an adult.\")\n}\n\n\n\n\nFactor data type is used to represent categorical data in R. Factors are stored as integers with associated labels, making them efficient for statistical modeling and analysis.\n\nExample 5  \n# Creating a factor variable\ngender &lt;- factor(c(\"Male\", \"Female\", \"Female\", \"Male\"))\nclass(gender) # Output: \"factor\"\n\n# Summary statistics with factors\ntable(gender)\n\n\n\n\nDate and time data types are crucial for handling temporal information in R. R provides specialized classes for dates (Date) and date-time values (POSIXct, POSIXlt).\n\nExample 6  \n# Creating a date variable\ntoday &lt;- as.Date(\"2024-04-25\")\nclass(today) # Output: \"Date\"\n\n# Date arithmetic\nnext_week &lt;- today + 7\n\n# Creating a POSIXct variable (date-time)\ncurrent_time &lt;- Sys.time()\nclass(current_time) # Output: \"POSIXct\"\n\nIn this post we learned about different R data types and what kind of data do they hold. Data type is very important concept in programming and can not be ignored. We have explained about each data type with example in this article."
  },
  {
    "objectID": "posts/dataTypes/index.html#introduction",
    "href": "posts/dataTypes/index.html#introduction",
    "title": "Understanding and using Data types in R",
    "section": "",
    "text": "In the realm of data science and statistical analysis, mastering data types is akin to understanding the building blocks of a language. In R, a powerful statistical computing language, data types form the foundation upon which all analyses are conducted. From integers to dates, each data type serves a unique purpose and understanding their nuances is critical for efficient and accurate data manipulation.\nUnderstanding and effectively utilizing these core data types in R is essential for performing data analysis, visualization, and modeling tasks. Mastery of data types empowers data scientists to manipulate data efficiently and extract valuable insights from complex datasets. Whether performing arithmetic operations, manipulating text, or handling temporal information, the versatility of R’s data types makes it a powerful tool for data analysis and statistical computing.\nIn this guide, we will delve into the core data types in R, exploring their characteristics and providing illustrative examples. Before we dive in, let pause for a moment and watch video in Figure 1\n\n\n\n\n\n\nFigure 1: Primary data types in R\n\n\n\n\n\nIntegers are whole numbers without any decimal or fractional component. In R, integers are represented by the integer class. They are commonly used for indexing and counting operations.\n\nExample 1  \n# Creating an integer variable\nx &lt;- 5L\nclass(x) # Output: \"integer\"\n\n# Arithmetic operations with integers\ny &lt;- x + 3\n\n\n\n\nNumeric data type, also known as double in other programming languages, represents numbers with decimal points. Numeric data types are used for most mathematical calculations and statistical operations in R.\n\nExample 2  \n# Creating a numeric variable\nheight &lt;- 175.5\nclass(height) # Output: \"numeric\"\n\n# Arithmetic operations with numeric variables\nbmi &lt;- weight / (height^2)\n\n\n\n\nCharacter data type represents textual data such as strings of letters, words, or sentences. In R, character values are enclosed in either single or double quotes.\n\nExample 3  \n# Creating a character variable\nname &lt;- \"John Doe\"\nclass(name) # Output: \"character\"\n\n# Concatenating character strings\ngreeting &lt;- paste(\"Hello\", name)\n\n\n\n\nLogical data type, often referred to as Boolean, represents binary values: TRUE or FALSE. Logical values are fundamental in controlling program flow and making decisions based on conditions.\n\nExample 4  \n# Creating logical variables\nis_adult &lt;- TRUE\nclass(is_adult) # Output: \"logical\"\n\n# Conditional statements with logical variables\nif (is_adult) {\n  print(\"You are an adult.\")\n} else {\n  print(\"You are not an adult.\")\n}\n\n\n\n\nFactor data type is used to represent categorical data in R. Factors are stored as integers with associated labels, making them efficient for statistical modeling and analysis.\n\nExample 5  \n# Creating a factor variable\ngender &lt;- factor(c(\"Male\", \"Female\", \"Female\", \"Male\"))\nclass(gender) # Output: \"factor\"\n\n# Summary statistics with factors\ntable(gender)\n\n\n\n\nDate and time data types are crucial for handling temporal information in R. R provides specialized classes for dates (Date) and date-time values (POSIXct, POSIXlt).\n\nExample 6  \n# Creating a date variable\ntoday &lt;- as.Date(\"2024-04-25\")\nclass(today) # Output: \"Date\"\n\n# Date arithmetic\nnext_week &lt;- today + 7\n\n# Creating a POSIXct variable (date-time)\ncurrent_time &lt;- Sys.time()\nclass(current_time) # Output: \"POSIXct\"\n\nIn this post we learned about different R data types and what kind of data do they hold. Data type is very important concept in programming and can not be ignored. We have explained about each data type with example in this article."
  },
  {
    "objectID": "posts/dataTypes/index.html#references",
    "href": "posts/dataTypes/index.html#references",
    "title": "Understanding and using Data types in R",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "posts/datastructures/index.html",
    "href": "posts/datastructures/index.html",
    "title": "Mastering Data Structures in R",
    "section": "",
    "text": "In data analysis and statistical computing, mastering data structures is essential for efficient data manipulation and analysis. In R, a powerful language for statistical computing and graphics, two fundamental data structures are vectors and data frames. Additionally, the newer tibble data structure offers enhanced features for data manipulation and visualization. In this comprehensive guide, we will explore these data structures in detail, providing illustrative examples along the way.Before we dive in, let pause for a moment and watch video in Figure 1\n\n\n\n\n\n\nFigure 1: Primary data structure in R"
  },
  {
    "objectID": "posts/datastructures/index.html#introduction",
    "href": "posts/datastructures/index.html#introduction",
    "title": "Mastering Data Structures in R",
    "section": "",
    "text": "In data analysis and statistical computing, mastering data structures is essential for efficient data manipulation and analysis. In R, a powerful language for statistical computing and graphics, two fundamental data structures are vectors and data frames. Additionally, the newer tibble data structure offers enhanced features for data manipulation and visualization. In this comprehensive guide, we will explore these data structures in detail, providing illustrative examples along the way.Before we dive in, let pause for a moment and watch video in Figure 1\n\n\n\n\n\n\nFigure 1: Primary data structure in R"
  },
  {
    "objectID": "posts/datastructures/index.html#vectors",
    "href": "posts/datastructures/index.html#vectors",
    "title": "Mastering Data Structures in R",
    "section": "Vectors:",
    "text": "Vectors:\nVectors are one-dimensional arrays that can hold numeric, character, logical, or other atomic data types. They are the simplest and most basic data structure in R.\n\nCreating Vectors:\nCreating vectors in R is straightforward using the c() function, which concatenates elements into a vector.\n# Creating a numeric vector\nnumeric_vector &lt;- c(1, 2, 3, 4, 5)\n\n# Creating a character vector\ncharacter_vector &lt;- c(\"apple\", \"banana\", \"orange\", \"grape\", \"pineapple\")\n\n# Creating a logical vector\nlogical_vector &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE)\n\n\nUsing Vectors to Create Data Frames:\nData frames are two-dimensional data structures that resemble tables, where each column can be a different data type. They are commonly used for storing and analyzing structured data.\n# Using vectors to create a data frame\ndata &lt;- data.frame(\n  numeric_col = numeric_vector,\n  character_col = character_vector,\n  logical_col = logical_vector\n)\n\n# View the created data frame\nprint(data)"
  },
  {
    "objectID": "posts/datastructures/index.html#data-frames",
    "href": "posts/datastructures/index.html#data-frames",
    "title": "Mastering Data Structures in R",
    "section": "Data Frames:",
    "text": "Data Frames:\nData frames are the workhorse of R for storing tabular data. They are similar to matrices but offer more flexibility, as each column can be of a different data type.\n\nCreating Data Frames:\nData frames can be created directly using the data.frame() function, where each column is specified as a vector.\n# Creating a data frame directly\nstudent_data &lt;- data.frame(\n  name = c(\"John\", \"Alice\", \"Bob\", \"Emma\", \"Michael\"),\n  age = c(25, 23, 27, 22, 24),\n  grade = c(\"A\", \"B\", \"B\", \"C\", \"A\")\n)\n\n# View the created data frame\nprint(student_data)\n\nUsing Tibbles:\nTibbles are a modern alternative to data frames, introduced by the tidyverse ecosystem. They are more user-friendly, provide enhanced printing, and have better support for data analysis pipelines.\n# Creating a tibble from vectors\nlibrary(tibble)\n\n# Creating a tibble directly\nstudent_tibble &lt;- tibble(\n  name = c(\"John\", \"Alice\", \"Bob\", \"Emma\", \"Michael\"),\n  age = c(25, 23, 27, 22, 24),\n  grade = c(\"A\", \"B\", \"B\", \"C\", \"A\")\n)\n\n# View the created tibble\nprint(student_tibble)"
  },
  {
    "objectID": "posts/datastructures/index.html#conclusion",
    "href": "posts/datastructures/index.html#conclusion",
    "title": "Mastering Data Structures in R",
    "section": "Conclusion:",
    "text": "Conclusion:\nUnderstanding data structures such as vectors, data frames, and tibbles is crucial for effective data manipulation and analysis in R. Whether you’re working with numeric data, text data, or logical data, these data structures provide the foundation for organizing and analyzing your data efficiently. By mastering these data structures, you’ll be well-equipped to tackle a wide range of data analysis tasks in R.\nIn this guide, we’ve covered how to create vectors, use them to construct data frames, and introduced the newer tibble data structure. Armed with this knowledge, you’re ready to dive deeper into the world of data analysis and unlock the full potential of R for your projects. Whether you’re a beginner or an experienced R user, mastering these fundamental data structures will pave the way for more advanced data analysis and modeling techniques."
  },
  {
    "objectID": "posts/datastructures/index.html#references",
    "href": "posts/datastructures/index.html#references",
    "title": "Mastering Data Structures in R",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "posts/basicplots/index.html",
    "href": "posts/basicplots/index.html",
    "title": "Basic plots with ggplot2",
    "section": "",
    "text": "The ggplot2 package provides a set of functions that mirror the Grammar of Graphics (Wickham, 2016), enabling you to efficaciously specify what you want a plot to look like. To have a glimpse of ggplot2, we start with five basic types of plots that are familiar to most people. These include: scatterplot, linegraphs, boxplots, histograms, and barplots. The first four graphs works with quantitative data and barplots are appropriate for categorical data.\nThus, understanding the type of data is inevitable before you throw the variable into ggplot2 to make plot for you. In this post, we will cover the most common plot types, such as line plots, histograms, pie charts, scatter plots, and bar plots, along with several other plot types that build upon these.\n\n\nScatterplots are also called bivariate, allows you to visualize the association between two numerical variables. They are among the widely used plot in fisheries science particularly when looking for association between length and weight of a particular fish. Probably you might have come across a scatterplot like the one in Figure 1 that base R was used, but probably you have not made one based on the fundamental theorem of grammar of graphics.\n\n\n\n\n\n\n\n\nFigure 1: Length and weight relationship of Chinook Salmon sampled in Atantic Ocean\n\n\n\n\n\nWe are going to visualize the relationship between length and weight of fish measured in the coastal waters of Kenya. We use the tidy_LFQ_sample_4.csv file. Let’s import the dataset in the session using read_csv function.\n\nlfq4 = read_csv(\"../data/tidy/tidy_LFQ_sample_4.csv\")\n\nThis file contain length and weight measurements along with sex sampled in Mombasa and Voi from March 2016 to September 2020 (Table 1).\n\n\n\n\nTable 1: Sample length and weight of sampled fish\n\n\n\nsitedatetl_mmfl_mmwt_gmsexMombasa2019-04-0518416959.50MMombasa2019-04-0518516954.71MMombasa2019-04-0514513424.15MVoi2020-09-1118917465.88FVoi2020-09-1116214736.35FVoi2020-09-1116815346.13F\n\n\n\n\n\nLet’s now dive into the code of using the *grammar of graphics to create the scatterplot. We use the ggplot() function from ggplot2** package. The code highlighted in the chunk below was used to plot Figure 2\n\nggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")\n\n\n\n\n\n\n\nFigure 2: Length and weight relationship\n\n\n\n\n\nLet’s explore the code above piece-by-piece\n\nThe plotting in ggplot2 begin with ggplot() function, where the two components of grammar of graphics are required. in the data component we specified the dataset by setting data = lfq4. Then the second argument aesthetic that map the plot with coordinate was set by aes(x = tl_mm, y = wt_gm)). In a nutshell, the aes() define the variable – axis specifications.\nWe then added a layer to the ggplot() function call using the + sign. The added layer specify the third part of the *grammar—the geometric component. Because we want to plot scatterplot, the appropriate geom for this case is the geom_point().\nadded a layer labs that allows us to label axis with meaningful axis titles\n\nadding regression line you can simply add the regression line by adding a geom_smooth() layer. However, Figure 2 is non-linear and hence we need to specify the modal that fits the data, the loess model is mostly used for non-linear data. Therefore, we parse the argumentmethod = \"loess\" to draw a non-linear regression line but also parse an argument se = FALSE to prevent plotting confidence error.\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"loess\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")\n\n\n\n\n\n\n\nFigure 3: Length and weight relationship with non-linear regression line\n\n\n\n\n\nIf we want to add a linear regression line i the scatter plot instead of the non linear shown in (ig-scatter2?), we simply replace method = \"loess\" with method = \"lm\"\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")\n\n\n\n\n\n\n\nFigure 4: Length and weight relationship with linear regression line\n\n\n\n\n\nThe linear regression line we added in Figure 4 does not fit the data points. That’s is nature of the length and weight measurements of most fishes as their growth is allometric and not isometric. To make use of the linear model in such data points, we often log-transform the data points first and replot. But in ggplot framework, you do need to do that but simply add the scale_x_log10 and scale_y_log10 layer\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  scale_x_log10() +\n  scale_y_log10()\n\n\n\n\n\n\n\nFigure 5: Log-transformed length and weight relationship with linear regression line\n\n\n\n\n\nKnowing whether the relationship is positive or negative and whether is linear or non linear is one thing, but people would like to know the strength of the relationship that you have simply presented in Figure 5. Luckily, Pedro Aphalo developed a ggpmisc package (Aphalo, 2016), which extend the statistical function of ggplot2. By simply adding a layer ggpmisc::stat_correlation() in Figure 5, the function generates labels for correlation coefficients and p-value, coefficient of determination (R^2) for method “pearson” and number of observations and add them into the plot (Figure 6).\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  scale_x_log10() +\n  scale_y_log10()+\n  ggpmisc::stat_correlation()\n\n\n\n\n\n\n\nFigure 6: Log-transformed length and weight relationship with linear regression line with correlation coefficient\n\n\n\n\n\nWe might be interested to distinguish the data points and the regression line based on the site. We can do that by adding the color argument in the aesthetic, which change from aes(x = tl_mm, y = wt_gm) to aes(x = tl_mm, y = wt_gm, color = site). The argument color = site will force the data points and the regression line to adhere to colors based on the site but the points and line are plotted on the same plot.\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm, color = site))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  scale_x_log10() +\n  scale_y_log10()+\n  ggpmisc::stat_correlation()\n\n\n\n\n\n\n\nFigure 7: Log-transformed length and weight relationship with linear regression line by site\n\n\n\n\n\nLooking on Figure 7, it is clear that sample from Mombasa station has relatively bigger and heavier fish than those sampled from Voi. But the problem with Figure 7 is that most of the Mombasa data points are masked by Voi data points, which are overlaid on Mombasa data points. We can overcome the issue of point cluttering by simply adding a transparency level in point with alpha = .2.\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm, color = site))+\n  geom_point(alpha = .2)+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  ggpmisc::stat_correlation()+\n  scale_x_log10() +\n  scale_y_log10()+\n  ggpmisc::stat_correlation()\n\n\n\n\n\n\n\nFigure 8: Log-transformed length and weight relationship with linear regression line by site. Points density is highlighted with transparency\n\n\n\n\n\nSometimes you may wish to plot Figure 8 as separate plot shown in Figure 9. That’s is achieved with facet_wrap function, which facet plots based on the levels that are in the variable that is specified. For instance, in our case, the variable chosen is site and there are two sites–Voi and Mombasa. Therefore by simply adding a facet_wrap(~site) layer will force ggplot to make two plots\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  scale_x_log10() +\n  scale_y_log10()+\n  ggpmisc::stat_correlation()+\n  facet_wrap(~site, nrow = 1)\n\n\n\n\n\n\n\nFigure 9: Faceted Log-transformed length and weight relationship with linear regression line\n\n\n\n\n\n\n\n\nThe next basic graph of ggplot2 is the linegraph. Line graphs is similar to drawing points, except that it connects the points with line. often times you don’t show the points. Let’s illustrate how to create linegraphs using catch data in the region. We first load the dataset in the session\n\nlanding.countries = read_csv(\"../data/tidy/landings_wio_country.csv\", skip = 4)\n\nThe landing.countries dataset contain 660 records of landed fisheries catch information recorded between 1950 and 2015 from Somalia, Kenya, Mozambique, South Africa, Madagascar, Mauritius, Seychelles, Mayotte, Tanzania and Zanzibar.\n\nlanding.countries %&gt;% \n  FSA::headtail() |&gt; \n  flextable::flextable() |&gt; \n  flextable::autofit()\n\nnameyearcatchepochKenya1,95019,1541,960Kenya1,95121,3181,960Kenya1,95219,1261,960Madagascar2,013266,9532,010Madagascar2,014138,4782,010Madagascar2,015145,6292,010\n\n\nLinegraphs are used to show time series data. Its inappropriate to use the linegraphs for data that has no clear sequential ordering and should be continuous and not discrete data type. The internal structure of the catch dataset we just loaded indicate that with exception of country’s name, year, catch and epoch are numeric values.\n\nlanding.countries %&gt;% \n  glimpse() \n\nRows: 660\nColumns: 4\n$ name  &lt;chr&gt; \"Kenya\", \"Kenya\", \"Kenya\", \"Kenya\", \"Kenya\", \"Kenya\", \"Kenya\", \"…\n$ year  &lt;dbl&gt; 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960…\n$ catch &lt;dbl&gt; 19154, 21318, 19126, 20989, 17541, 19223, 23297, 28122, 28819, 2…\n$ epoch &lt;dbl&gt; 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960…\n\n\nLet’s us plot the annual landings of fish over the period with ggplot. Like the scatterplot we made earlier, where supply the data frame in data argument and specified the aesthetic mapping with x and y coordinates, but instead of using geom_point(), we use the geom_line(). The code to make the line graph of annual landing in the WIO region shown in Figure 10 is written as;\n\nggplot(data = landing.countries,\n       aes(x = year, y = catch)) +\n  geom_line()+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 10: Annual alnding in the WIO region\n\n\n\n\n\nAlthough we added a geom_line, but we notice that Figure 10 display a plot which we did not expect. The problem is that line for the ten countries are all lumped together and result in the chaotic situation. For illustration purpose, I will use the catch data from Mauritius. Let’s filter Mauritius’ catch information from the landing.countries dataset and display its rows and variables;\n\nmauritius.landings = landing.countries %&gt;% \n  filter(name == \"Mauritius\")\n\n\nmauritius.landings %&gt;% \n  FSA::headtail() |&gt; \n  flextable::flextable() |&gt; \n  flextable::autofit()\n\nnameyearcatchepochMauritius1,950183,0821,960Mauritius1,951216,1511,960Mauritius1,952181,8221,960Mauritius2,01315,7972,010Mauritius2,01413,8792,010Mauritius2,01516,3732,010\n\n\nThere are only 66 rows in Mauritius which are equivalent to 66 records each per year from 1950 to 2015. Let’s use the mauritius.landings dataset to plot\n\nggplot(data = mauritius.landings,\n       aes(x = year, y = catch)) +\n  geom_line()+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 11: Mauritius’ annual landing\n\n\n\n\n\nOften times you find that linegraphs has points. You can also do that in ggplot environment by adding a geom_point layer\n\nggplot(data = mauritius.landings,\n       aes(x = year, y = catch)) +\n  geom_line()+\n  geom_point()+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 12: Mauritius’ annual landing\n\n\n\n\n\nYou can also customize the appearance of the line and point by parsing the color argument in the geom_point and geom_line layers\n\nggplot(data = mauritius.landings,\n       aes(x = year, y = catch)) +\n  geom_line(color = \"black\")+\n  geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 13: Mauritius’ annual landing\n\n\n\n\n\nThe problem we faced in Figure 10 is that catch data for all ten countries were pooled together, and the plot was not informative. But what is we want to compare the trend of catch among the countries. That is achieved by simply distinguishing the color layer for each country. That is done by adding an argument color=name in aes function as the code below highlight\n\nggplot(data = landing.countries,\n       aes(x = year, y = catch, color = name)) +\n  geom_line()+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 14: Annual landing by countries in the WIO region\n\n\n\n\n\nThe landings from South Africa is far higher than the rest of the WIO’s countries, which overshadow the appearance of other countries (Figure 14). There several approaches to resolve this issues where some countries have low catch values while others have relatively very high catches. For our case, we have decided to remove South Africa from the plot. We can do that by negating the selection with filter function from dplyr package. By parsing filter(!name == \"South Africa\"), note the exclamation mark before name tell to reverse selection and therefore select all countries except South Africa.\n\nother.countries = landing.countries %&gt;% \n  filter(!name == \"South Africa\")\n\nWe then plot and parse the argument data = other.countries instead of data = landing.countries to make Figure 15.\n\nggplot(data = other.countries,\n       aes(x = year, y = catch, color = name)) +\n  geom_line()+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 15: Annual landing by countries in the WIO region with South Africa ommited\n\n\n\n\n\nWe notice that Tanzania and Zanzibar are presented as separate entity. Although the two states report to the FAO separate, but would be interested to know the landing of the combined Tanzania and Zanzibar catches. But before we combine these two states, lets see how their catches vary over the period. First we need to select only records for Tanzania and Zanzibar using a filter function as illustrated below;\n\ntanzania.zanzibar = landing.countries %&gt;% \n  filter(name %in% c(\"Tanzania\", \"Zanzibar\")) \n\nOnce we have created a tanzania.zanzibar object, we can use it to make plots that compare catch trend of Tanzania and Zanzibar over the last 66 years. The code in this chunk is used to make Figure 16\n\n  ggplot(data = tanzania.zanzibar,\n       aes(x = year, y = catch, color = name)) +\n  geom_line()+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 16: Annual landing for mainland Tanzania and Zanzibar\n\n\n\n\n\n\nlanding.countries %&gt;% \n  mutate(name = str_replace(string = name, \n                            pattern = \"Zanzibar\", \n                            replacement = \"Tanzania\")) %&gt;% \n  filter(!name == \"South Africa\") %&gt;% \n  group_by(name, year) %&gt;% \n  summarise(catch_new = sum(catch, na.rm = TRUE)) %&gt;% \n  ggplot(\n       aes(x = year, y = catch_new, color = name)) +\n  geom_line()+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 17: Annual landing for WIO where mainland Tanzania and Zanzibar are combined\n\n\n\n\n\n\n\n\nThe geom_area method is used to create an area plot. It can be used as a component in the ggplot method. The alpha parameter in the geom_area method is used to depict the opacity of a genome, the value ranges from zero to one integral values. In case, we choose a lower value, this means that a more transparent color version will be chosen to depict the plot and its smoothness. We have used the value for the alpha parameter to be one by two means it is somewhat translucent in nature.\n\n  ggplot(data = tanzania.zanzibar,\n       aes(x = year, y = catch, fill = name)) +\n  geom_area(alpha = 0.6, position=\"identity\")+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 18: Area plot showing Annual landing for mainland Tanzania and Zanzibar\n\n\n\n\n\n\n\n\nA histogram is a plot that can be used to examine the shape and spread of continuous data. It looks very similar to a bar graph and organized in intervals or classes. It divides the range of the data into bin equal intervals (also called bins or classes), count the number of observations in each bin, and display the frequency distribution of observations as a bar plot. Such histogram plots provide valuable information on the characteristics of the data, such as the central tendency, the dispersion and the general shape of the distribution. With lfq4 dataset, we can plot the histogram of tl_mm. Since histogram works for single variable that contains quantitative values, you can not bother looking for relationship as we have seen in previous plots, but histogram offers an opportunity to answer question like\n\nWhat are the smallest and largest values of tl_mm?\nWhat is the center value? 3 How does these values spread out?\n\nWe can make a histogram shown in Figure 19 by simply setting aes(x = tl_mm) and add geom_histogram(). Within the geom_histogram(), we simply specify the number of bins bins = 30, fill color for the colum and also the color separating each columns of the histogram with col == \"red\" and fill = \"red\". However, a word of caution regarding histograms—bin size matters. The reproducible code to plot Figure 19 is written as;\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm)) +\n  geom_histogram(bins = 30, fill = \"red\", color = \"red\", alpha = 0.4)+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 19: Histogram of total length\n\n\n\n\n\nThe resulting histogram gives us an idea of the range of total length of fish we can expect from the sample. You may be interested to compare histogram of the data values sampled from two or sites. For example, in our case, we are interested to compare the distribution of total length using samples collected from Mombasa and Voi sites. We simply add the fill = site argument in the aes function\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm, fill = site)) +\n  geom_histogram(bins = 50, alpha = 0.6)+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 20: Histogram of total length by sites\n\n\n\n\n\nThe histogram of Mombasa and Voi is plotted as shown in Figure 20, however, despite the transparency level of the bins is set to 0.6 (alpha = .6), yet the bins from Mombasa are masked with bins from Voi. The voi bins are plotted over the Mombasa ones and prevent us to visualize the underneath Mombasa bins. To correct for this issue, we need to parse position = \"identity\"in the geom_bin, which create an different color where the Mombasa and Voi bins are intersected.\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm, fill = site)) +\n  geom_histogram(bins = 50, alpha = 0.6, position = \"identity\")+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 21: Histogram of total length by sites\n\n\n\n\n\n\n\n\nIt is often useful to visualise the distribution of a numerical variable. Comparing the distributions of different groups can lead to important insights. Visualising distributions is also essential when checking assumptions used for various statistical tests (sometimes called initial data analysis). In this section we will illustrate how this can be done using the diamonds data from the ggplot2 package, which you started to explore in Chapter 2.\nAn advantage with frequency polygons is that they can be used to compare groups, e.g. diamonds with different cuts, without facetting:\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm, color = site)) +\n  geom_freqpoly(alpha = 0.6, position = \"identity\")+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 22: Frequency polygon of total length by sites\n\n\n\n\n\nIt is clear from this figure that the total length of fish from Voi is larger in size than those from Mombasa. The polygons have roughly the same shape, except the shape of Mombasa a long right tail indicating the presence of outlier points.\n\n\n\nIn some cases, we are more interested in the shape of the distribution than in the actual counts in the different bins. Density plots are similar to frequency polygons but show an estimate of the density function of the underlying random variable. These estimates are smooth curves that are scaled so that the area below them is 1 (i.e. scaled to be proper density functions):\n\n#|\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm, fill = site)) +\n  geom_density(alpha = 0.4, position = \"identity\")+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 23: Density plot of total length by sites\n\n\n\n\n\nFrom Figure 23, it’s clear that small size fish tend to have better total length, which wasn’t obvious from the frequency polygons. However, the plot does not provide any information about how common different total length are.\n\n\n\nThe boxplot is a standardized way of displaying the distribution of data based on the five number summary: minimum, first quantile, median, third quantile, and maximum. Boxplots are useful for detecting outliers and for comparing distributions. These five number summary also called the 25th percentile, median, and 75th percentile of the quantitative data. The whisker (vertical lines) capture roungly 99% of a distribution, and observation outside this range are plotted as points representing outliers as shown in Figure 24.\n\n\n\n\n\n\n\n\nFigure 24: Conceputal boxplot diagram\n\n\n\n\n\nBoxplots is one of statistical plot that present continuous variable and in ggplot a geom_boxplot() function is dedicated for that. The aes function always have at least two arguments. The first argument should be a categrial variable and the second one is numeric.\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm)) +\n  geom_boxplot(alpha = 0.6, position = \"identity\")+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 25: Boxplot of total length by sites\n\n\n\n\n\nthe geom_boxplot() has outlier_ arguments that allows to highlight and modify the color, shape, size, alpha … etc of outliers —extreme observation. For instance, you can highlight the outlier with;\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm, fill = site)) +\n  geom_boxplot(alpha = 0.6, position = \"identity\", outlier.colour = \"red\", outlier.color = )+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 26: Boxplot of total length by sites\n\n\n\n\n\nWe can also map the fill and color to variable in to distinguish boxplot. for example, we can specify the fill = site argument in the aes() to fill the boxplot based on site.\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm, fill = site)) +\n  geom_boxplot(alpha = 0.6, position = \"identity\", outlier.colour = \"red\", outlier.color = )+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 27: Boxplot of total length and color to distinguish sites\n\n\n\n\n\nWe can add the points on top of the boxplot with the geom_jitter(). It also allows for specifying other arguments like colors and width of the points.\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm, fill = site)) +\n  geom_boxplot(alpha = 0.6, position = \"identity\", \n               outlier.colour = \"red\", outlier.color = )+\n  geom_jitter(width = .1, height = .5, alpha = 0.1)+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 28: Boxplot with points of total length by sites\n\n\n\n\n\n\n\n\nInstead of using a boxplot, we can use a violin plot. Each group is represented by a “violin”, given by a rotated and duplicated density plot:\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm, fill = site)) +\n  geom_violin(alpha = 0.6, position = \"identity\")+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 29: Violin of total length by sites\n\n\n\n\n\n\n\n\nBar graphs are perhaps the widely used plot. They are typically used to display count values on the y-axis for different groups on the x-axis. There is an important distinction you should be aware of when making bar graphs. The height of a bar in barplot may represent either the counts or percentage of elements in the dataset. Let’s begin with the former—count. We use the shrimps_cleaned.csv dataset, which contains weight and length of four shrimp species. To access the variable and values of this file we need to load the file using a read_csv function as the code in the chunk below highlight;\n\nshrimp = read_csv(\"../data/tidy/shrimps_cleaned.csv\")\n\nThe sample dataset of shrimp is shown in Table 2. It contain six variables year, season, tide, species, weight (total_wt_kg) and length (tl_mm).\n\n\n\n\nTable 2: Shrimp dataset\n\n\n\n\n\n\n\n\n\n\nyear\nseason\ntide\nspecies\ntotal_wt_kg\ntl_mm\n\n\n\n\n2008\nWET\nSTF\nMetapenaeus monoceros\n2.0\n21\n\n\n2008\nWET\nSTF\nMetapenaeus monoceros\n2.0\n20\n\n\n2008\nWET\nSTF\nMetapenaeus monoceros\n2.0\n19\n\n\n2012\nDRY\nSTN\nPenaeus monodon\n1.7\n12\n\n\n2012\nDRY\nSTN\nFenneropenaeus indicus\n1.7\n14\n\n\n2012\nDRY\nSTN\nPenaeus monodon\n1.7\n11\n\n\n\n\n\n\n\n\n\n\n\nWe realize that the scientific names are too long and may not fit into the plotting area. Therefore, we use a case_when function from dplyr package to change species name and assign it as a new variable called species.short\n\nshrimp = shrimp %&gt;% \n  mutate(species.short = case_when(\n    species == \"Metapenaeus monoceros\"~ \"M.monoceros\",\n    species == \"Penaeus monodon\"~ \"P.monodon\",\n    species == \"Fenneropenaeus indicus\"~ \"F.indicus\",\n    species == \"Penaeus semisulcatus\"~ \"P.semisulcatus\")\n    ) %&gt;% \n  relocate(species.short, .after = species)\n\n\n\nTo make the bar graph that show the number of shrimp per species over the sampling period you you simply specify the the variable species in the x coordinates in the aesthetic and add the geom_bar()\n\nggplot(data = shrimp, aes(x = species.short))+\n  geom_bar()+\n  labs(x = \"Species\", y= \"Frequency\")\n\n\n\n\n\n\n\nFigure 30: Frequency of shrimp species\n\n\n\n\n\nThen to stack the bar based on the sampling season, we add the argument fill = season in aes() part\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar()+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 31: Frequency of shrimp species by season\n\n\n\n\n\nYou can flip the order of bar with position = position_stack(reverse = TRUE)\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_stack(reverse = TRUE))+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 32: Frequency of shrimp species by season\n\n\n\n\n\nInstead of stacking, you can dodge the bar with position = position_dodge() argument\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_dodge())+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 33: Frequency of shrimp species by season with span\n\n\n\n\n\nWe notice that the species that only appear one season, the count for that species is span across and make the bar wideer than those species occur in both seasons. We can fix that by parsing position = position_dodge(preserve = \"single\") in the geom_bar function\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_dodge(preserve = \"single\"))+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 34: Frequency of shrimp species by season without span\n\n\n\n\n\nTo add a black stroke color of the bar, add the argument col = \"black\" inside the geom_bar()\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_dodge(preserve = \"single\"), color = \"black\")+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 35: Frequency of shrimp species by season without span with black bar color\n\n\n\n\n\nAnd to specify the width of the bar you specify a value in width=.75 argument in geom_bar()\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_dodge(preserve = \"single\"), color = \"black\", width = .75)+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 36: Frequency of shrimp species by season without span with black bar color\n\n\n\n\n\n\n\n\nWe have seen how to make barplot that show the count with geom_bar(). You can also use the barplot to show the values with the geom_col() function and specify what variables you want on the x and y axis. For instance, we want to show percentage of shrimp species by season. Because the geom_col() requires summarized statistics, we need to compute the percentage for each season as the chunk below highlight.\n\nshrimp.pct = shrimp %&gt;% \n  group_by(species.short, season) %&gt;% \n  summarise(n = n()) %&gt;% \n  mutate(pct = n/sum(n), \n         pct = (pct * 100) %&gt;% round(2))\n\nshrimp.pct\n\n# A tibble: 6 × 4\n# Groups:   species.short [4]\n  species.short  season     n   pct\n  &lt;chr&gt;          &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt;\n1 F.indicus      DRY      404 100  \n2 M.monoceros    DRY      539  86.9\n3 M.monoceros    WET       81  13.1\n4 P.monodon      DRY      738  52.4\n5 P.monodon      WET      671  47.6\n6 P.semisulcatus DRY      227 100  \n\n\nOnce we have computed the statistics, we can use them to make barplot. Note that unlike the geom_bar(), which need only the x variable, geom_col() requires x and y variables specified. For illustration, we specified the x = species, and y = pct in the aes() to make a barplot that show the percentage of shrimp by season (Figure 37).\n\nggplot(data = shrimp.pct, aes(x = species.short, y = pct, fill = season))+\n  geom_col(position = position_dodge(preserve = \"single\"), color = \"black\", width = .75)+\n  labs(x = \"Species\", y =\"Percentage\")\n\n\n\n\n\n\n\nFigure 37: Percentage of shrimp species by season without span with black bar color\n\n\n\n\n\n\n\n\n\nA pie chart is a disk divided into pie-shaped pieces proportional to the relative frequencies of the classes. To obtain angle for any class, we multiply the relative frequencies by 360 degree, which corresponds to the complete circle. Either variables or attributes can be portrayed in this manner, but a pie chart is especially useful for attributes. A pie diagram for contribution of different fish groups/species to the total fish landings at a landing site of a river is shown in Figure 38.\n\nshrimp %&gt;% \n  group_by(species) %&gt;% \n  summarise(n = n()) %&gt;% \n  mutate(pct = round(n/sum(n)*100), 2) %&gt;% \n  mutate(species = str_replace(string = species, pattern = \" \", replacement = \"\\n\")) %&gt;% \n  mutate(label = paste0(\"(\",pct,\"%\",\")\")) %&gt;% \n  ggpubr::ggpie(x = \"pct\", label = \"label\", fill = \"species\", lab.pos = \"in\", palette = \"jama\", color = \"ivory\", ggtheme = theme_void(), )\n\n\n\n\n\n\n\nFigure 38: Percentage composition of prawn species\n\n\n\n\n\nAn extended pie chart is donut shown in Figure 39\n\nshrimp %&gt;% \n  group_by(species) %&gt;% \n  summarise(n = n()) %&gt;% \n  mutate(pct = round(n/sum(n)*100), 2) %&gt;% \n  mutate(species = str_replace(string = species, pattern = \" \", replacement = \"\\n\")) %&gt;% \n  mutate(label = paste0(\"(\",pct,\"%\",\")\")) %&gt;% \n  ggpubr::ggdonutchart(x = \"pct\", label = \"label\", fill = \"species\", lab.pos = \"in\", palette = \"jama\", color = \"ivory\", ggtheme = theme_void())\n\n\n\n\n\n\n\nFigure 39: Percentage composition of prawn species\n\n\n\n\n\n\n\n\n\nshrimp %&gt;% \n  group_by(species.short) %&gt;% \n  count() %&gt;% \n  arrange(-n) %&gt;% \n  ggplot(aes(x = reorder(species.short,n), y = n, \n             fill = species.short), stat = \"identity\")+\n  geom_col() +\n  coord_polar(theta = \"y\")+\n  theme_bw() +\n  theme(axis.title = element_blank(), legend.position = \"right\", axis.text.y = element_blank(), axis.ticks = element_blank())+\n  scale_fill_brewer(palette = \"Set2\", name = \"Species\")\n\n\n\n\n\n\n\nFigure 40: Barplot with polar transformation\n\n\n\n\n\n\nshrimp %&gt;% \n  ggplot() +\n  geom_bar(aes(x = tide, fill = species.short),\n           color = \"ivory\") +\n  labs(x = \"Tide\", y = \"Count\") +\n  coord_polar()+\n  theme_bw() +\n  theme(axis.title = element_blank(), \n        legend.position = \"right\")+\n  scale_fill_brewer(palette = \"Set2\", name = \"Species\")\n\n\n\n\n\n\n\nFigure 41: Stacked barplot with polar transformation\n\n\n\n\n\n\n\n\nAlthough the ggridges package provides geom_ridgeline and geom_density_ridges, we focus on the latter because it has ability to estimates data densities and then draws those using ridgelines.The geom geom_density_ridges calculates density estimates from the provided data and then plots those, using the ridgeline visualization.\n\nlfq4 %&gt;% \n  mutate(months = lubridate::month(date, label = TRUE)) %&gt;%\n  ggplot()+\n  ggridges::geom_density_ridges(aes(x = tl_mm, y = months, fill = site), alpha = .7)+\n  scale_fill_brewer(palette = \"Set2\", name = \"Sampling\\nsite\")+\n  theme_minimal()+\n  theme(legend.position = c(.85,.2), legend.background = element_rect())+\n  labs(y = \"Months\", x = \"Total length (mm.)\")"
  },
  {
    "objectID": "posts/basicplots/index.html#introduction",
    "href": "posts/basicplots/index.html#introduction",
    "title": "Basic plots with ggplot2",
    "section": "",
    "text": "The ggplot2 package provides a set of functions that mirror the Grammar of Graphics (Wickham, 2016), enabling you to efficaciously specify what you want a plot to look like. To have a glimpse of ggplot2, we start with five basic types of plots that are familiar to most people. These include: scatterplot, linegraphs, boxplots, histograms, and barplots. The first four graphs works with quantitative data and barplots are appropriate for categorical data.\nThus, understanding the type of data is inevitable before you throw the variable into ggplot2 to make plot for you. In this post, we will cover the most common plot types, such as line plots, histograms, pie charts, scatter plots, and bar plots, along with several other plot types that build upon these.\n\n\nScatterplots are also called bivariate, allows you to visualize the association between two numerical variables. They are among the widely used plot in fisheries science particularly when looking for association between length and weight of a particular fish. Probably you might have come across a scatterplot like the one in Figure 1 that base R was used, but probably you have not made one based on the fundamental theorem of grammar of graphics.\n\n\n\n\n\n\n\n\nFigure 1: Length and weight relationship of Chinook Salmon sampled in Atantic Ocean\n\n\n\n\n\nWe are going to visualize the relationship between length and weight of fish measured in the coastal waters of Kenya. We use the tidy_LFQ_sample_4.csv file. Let’s import the dataset in the session using read_csv function.\n\nlfq4 = read_csv(\"../data/tidy/tidy_LFQ_sample_4.csv\")\n\nThis file contain length and weight measurements along with sex sampled in Mombasa and Voi from March 2016 to September 2020 (Table 1).\n\n\n\n\nTable 1: Sample length and weight of sampled fish\n\n\n\nsitedatetl_mmfl_mmwt_gmsexMombasa2019-04-0518416959.50MMombasa2019-04-0518516954.71MMombasa2019-04-0514513424.15MVoi2020-09-1118917465.88FVoi2020-09-1116214736.35FVoi2020-09-1116815346.13F\n\n\n\n\n\nLet’s now dive into the code of using the *grammar of graphics to create the scatterplot. We use the ggplot() function from ggplot2** package. The code highlighted in the chunk below was used to plot Figure 2\n\nggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")\n\n\n\n\n\n\n\nFigure 2: Length and weight relationship\n\n\n\n\n\nLet’s explore the code above piece-by-piece\n\nThe plotting in ggplot2 begin with ggplot() function, where the two components of grammar of graphics are required. in the data component we specified the dataset by setting data = lfq4. Then the second argument aesthetic that map the plot with coordinate was set by aes(x = tl_mm, y = wt_gm)). In a nutshell, the aes() define the variable – axis specifications.\nWe then added a layer to the ggplot() function call using the + sign. The added layer specify the third part of the *grammar—the geometric component. Because we want to plot scatterplot, the appropriate geom for this case is the geom_point().\nadded a layer labs that allows us to label axis with meaningful axis titles\n\nadding regression line you can simply add the regression line by adding a geom_smooth() layer. However, Figure 2 is non-linear and hence we need to specify the modal that fits the data, the loess model is mostly used for non-linear data. Therefore, we parse the argumentmethod = \"loess\" to draw a non-linear regression line but also parse an argument se = FALSE to prevent plotting confidence error.\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"loess\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")\n\n\n\n\n\n\n\nFigure 3: Length and weight relationship with non-linear regression line\n\n\n\n\n\nIf we want to add a linear regression line i the scatter plot instead of the non linear shown in (ig-scatter2?), we simply replace method = \"loess\" with method = \"lm\"\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")\n\n\n\n\n\n\n\nFigure 4: Length and weight relationship with linear regression line\n\n\n\n\n\nThe linear regression line we added in Figure 4 does not fit the data points. That’s is nature of the length and weight measurements of most fishes as their growth is allometric and not isometric. To make use of the linear model in such data points, we often log-transform the data points first and replot. But in ggplot framework, you do need to do that but simply add the scale_x_log10 and scale_y_log10 layer\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  scale_x_log10() +\n  scale_y_log10()\n\n\n\n\n\n\n\nFigure 5: Log-transformed length and weight relationship with linear regression line\n\n\n\n\n\nKnowing whether the relationship is positive or negative and whether is linear or non linear is one thing, but people would like to know the strength of the relationship that you have simply presented in Figure 5. Luckily, Pedro Aphalo developed a ggpmisc package (Aphalo, 2016), which extend the statistical function of ggplot2. By simply adding a layer ggpmisc::stat_correlation() in Figure 5, the function generates labels for correlation coefficients and p-value, coefficient of determination (R^2) for method “pearson” and number of observations and add them into the plot (Figure 6).\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  scale_x_log10() +\n  scale_y_log10()+\n  ggpmisc::stat_correlation()\n\n\n\n\n\n\n\nFigure 6: Log-transformed length and weight relationship with linear regression line with correlation coefficient\n\n\n\n\n\nWe might be interested to distinguish the data points and the regression line based on the site. We can do that by adding the color argument in the aesthetic, which change from aes(x = tl_mm, y = wt_gm) to aes(x = tl_mm, y = wt_gm, color = site). The argument color = site will force the data points and the regression line to adhere to colors based on the site but the points and line are plotted on the same plot.\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm, color = site))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  scale_x_log10() +\n  scale_y_log10()+\n  ggpmisc::stat_correlation()\n\n\n\n\n\n\n\nFigure 7: Log-transformed length and weight relationship with linear regression line by site\n\n\n\n\n\nLooking on Figure 7, it is clear that sample from Mombasa station has relatively bigger and heavier fish than those sampled from Voi. But the problem with Figure 7 is that most of the Mombasa data points are masked by Voi data points, which are overlaid on Mombasa data points. We can overcome the issue of point cluttering by simply adding a transparency level in point with alpha = .2.\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm, color = site))+\n  geom_point(alpha = .2)+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  ggpmisc::stat_correlation()+\n  scale_x_log10() +\n  scale_y_log10()+\n  ggpmisc::stat_correlation()\n\n\n\n\n\n\n\nFigure 8: Log-transformed length and weight relationship with linear regression line by site. Points density is highlighted with transparency\n\n\n\n\n\nSometimes you may wish to plot Figure 8 as separate plot shown in Figure 9. That’s is achieved with facet_wrap function, which facet plots based on the levels that are in the variable that is specified. For instance, in our case, the variable chosen is site and there are two sites–Voi and Mombasa. Therefore by simply adding a facet_wrap(~site) layer will force ggplot to make two plots\n\n  ggplot(data = lfq4, aes(x = tl_mm, y = wt_gm))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = FALSE)+\n  labs(x = \"Total length (mm)\", y = \"Weight (gm)\")+\n  scale_x_log10() +\n  scale_y_log10()+\n  ggpmisc::stat_correlation()+\n  facet_wrap(~site, nrow = 1)\n\n\n\n\n\n\n\nFigure 9: Faceted Log-transformed length and weight relationship with linear regression line\n\n\n\n\n\n\n\n\nThe next basic graph of ggplot2 is the linegraph. Line graphs is similar to drawing points, except that it connects the points with line. often times you don’t show the points. Let’s illustrate how to create linegraphs using catch data in the region. We first load the dataset in the session\n\nlanding.countries = read_csv(\"../data/tidy/landings_wio_country.csv\", skip = 4)\n\nThe landing.countries dataset contain 660 records of landed fisheries catch information recorded between 1950 and 2015 from Somalia, Kenya, Mozambique, South Africa, Madagascar, Mauritius, Seychelles, Mayotte, Tanzania and Zanzibar.\n\nlanding.countries %&gt;% \n  FSA::headtail() |&gt; \n  flextable::flextable() |&gt; \n  flextable::autofit()\n\nnameyearcatchepochKenya1,95019,1541,960Kenya1,95121,3181,960Kenya1,95219,1261,960Madagascar2,013266,9532,010Madagascar2,014138,4782,010Madagascar2,015145,6292,010\n\n\nLinegraphs are used to show time series data. Its inappropriate to use the linegraphs for data that has no clear sequential ordering and should be continuous and not discrete data type. The internal structure of the catch dataset we just loaded indicate that with exception of country’s name, year, catch and epoch are numeric values.\n\nlanding.countries %&gt;% \n  glimpse() \n\nRows: 660\nColumns: 4\n$ name  &lt;chr&gt; \"Kenya\", \"Kenya\", \"Kenya\", \"Kenya\", \"Kenya\", \"Kenya\", \"Kenya\", \"…\n$ year  &lt;dbl&gt; 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960…\n$ catch &lt;dbl&gt; 19154, 21318, 19126, 20989, 17541, 19223, 23297, 28122, 28819, 2…\n$ epoch &lt;dbl&gt; 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960, 1960…\n\n\nLet’s us plot the annual landings of fish over the period with ggplot. Like the scatterplot we made earlier, where supply the data frame in data argument and specified the aesthetic mapping with x and y coordinates, but instead of using geom_point(), we use the geom_line(). The code to make the line graph of annual landing in the WIO region shown in Figure 10 is written as;\n\nggplot(data = landing.countries,\n       aes(x = year, y = catch)) +\n  geom_line()+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 10: Annual alnding in the WIO region\n\n\n\n\n\nAlthough we added a geom_line, but we notice that Figure 10 display a plot which we did not expect. The problem is that line for the ten countries are all lumped together and result in the chaotic situation. For illustration purpose, I will use the catch data from Mauritius. Let’s filter Mauritius’ catch information from the landing.countries dataset and display its rows and variables;\n\nmauritius.landings = landing.countries %&gt;% \n  filter(name == \"Mauritius\")\n\n\nmauritius.landings %&gt;% \n  FSA::headtail() |&gt; \n  flextable::flextable() |&gt; \n  flextable::autofit()\n\nnameyearcatchepochMauritius1,950183,0821,960Mauritius1,951216,1511,960Mauritius1,952181,8221,960Mauritius2,01315,7972,010Mauritius2,01413,8792,010Mauritius2,01516,3732,010\n\n\nThere are only 66 rows in Mauritius which are equivalent to 66 records each per year from 1950 to 2015. Let’s use the mauritius.landings dataset to plot\n\nggplot(data = mauritius.landings,\n       aes(x = year, y = catch)) +\n  geom_line()+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 11: Mauritius’ annual landing\n\n\n\n\n\nOften times you find that linegraphs has points. You can also do that in ggplot environment by adding a geom_point layer\n\nggplot(data = mauritius.landings,\n       aes(x = year, y = catch)) +\n  geom_line()+\n  geom_point()+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 12: Mauritius’ annual landing\n\n\n\n\n\nYou can also customize the appearance of the line and point by parsing the color argument in the geom_point and geom_line layers\n\nggplot(data = mauritius.landings,\n       aes(x = year, y = catch)) +\n  geom_line(color = \"black\")+\n  geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 13: Mauritius’ annual landing\n\n\n\n\n\nThe problem we faced in Figure 10 is that catch data for all ten countries were pooled together, and the plot was not informative. But what is we want to compare the trend of catch among the countries. That is achieved by simply distinguishing the color layer for each country. That is done by adding an argument color=name in aes function as the code below highlight\n\nggplot(data = landing.countries,\n       aes(x = year, y = catch, color = name)) +\n  geom_line()+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 14: Annual landing by countries in the WIO region\n\n\n\n\n\nThe landings from South Africa is far higher than the rest of the WIO’s countries, which overshadow the appearance of other countries (Figure 14). There several approaches to resolve this issues where some countries have low catch values while others have relatively very high catches. For our case, we have decided to remove South Africa from the plot. We can do that by negating the selection with filter function from dplyr package. By parsing filter(!name == \"South Africa\"), note the exclamation mark before name tell to reverse selection and therefore select all countries except South Africa.\n\nother.countries = landing.countries %&gt;% \n  filter(!name == \"South Africa\")\n\nWe then plot and parse the argument data = other.countries instead of data = landing.countries to make Figure 15.\n\nggplot(data = other.countries,\n       aes(x = year, y = catch, color = name)) +\n  geom_line()+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 15: Annual landing by countries in the WIO region with South Africa ommited\n\n\n\n\n\nWe notice that Tanzania and Zanzibar are presented as separate entity. Although the two states report to the FAO separate, but would be interested to know the landing of the combined Tanzania and Zanzibar catches. But before we combine these two states, lets see how their catches vary over the period. First we need to select only records for Tanzania and Zanzibar using a filter function as illustrated below;\n\ntanzania.zanzibar = landing.countries %&gt;% \n  filter(name %in% c(\"Tanzania\", \"Zanzibar\")) \n\nOnce we have created a tanzania.zanzibar object, we can use it to make plots that compare catch trend of Tanzania and Zanzibar over the last 66 years. The code in this chunk is used to make Figure 16\n\n  ggplot(data = tanzania.zanzibar,\n       aes(x = year, y = catch, color = name)) +\n  geom_line()+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 16: Annual landing for mainland Tanzania and Zanzibar\n\n\n\n\n\n\nlanding.countries %&gt;% \n  mutate(name = str_replace(string = name, \n                            pattern = \"Zanzibar\", \n                            replacement = \"Tanzania\")) %&gt;% \n  filter(!name == \"South Africa\") %&gt;% \n  group_by(name, year) %&gt;% \n  summarise(catch_new = sum(catch, na.rm = TRUE)) %&gt;% \n  ggplot(\n       aes(x = year, y = catch_new, color = name)) +\n  geom_line()+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 17: Annual landing for WIO where mainland Tanzania and Zanzibar are combined\n\n\n\n\n\n\n\n\nThe geom_area method is used to create an area plot. It can be used as a component in the ggplot method. The alpha parameter in the geom_area method is used to depict the opacity of a genome, the value ranges from zero to one integral values. In case, we choose a lower value, this means that a more transparent color version will be chosen to depict the plot and its smoothness. We have used the value for the alpha parameter to be one by two means it is somewhat translucent in nature.\n\n  ggplot(data = tanzania.zanzibar,\n       aes(x = year, y = catch, fill = name)) +\n  geom_area(alpha = 0.6, position=\"identity\")+\n  # geom_point(color = \"red\")+\n  labs(x = \"Year\", y = \"Annual catch (MT)\")\n\n\n\n\n\n\n\nFigure 18: Area plot showing Annual landing for mainland Tanzania and Zanzibar\n\n\n\n\n\n\n\n\nA histogram is a plot that can be used to examine the shape and spread of continuous data. It looks very similar to a bar graph and organized in intervals or classes. It divides the range of the data into bin equal intervals (also called bins or classes), count the number of observations in each bin, and display the frequency distribution of observations as a bar plot. Such histogram plots provide valuable information on the characteristics of the data, such as the central tendency, the dispersion and the general shape of the distribution. With lfq4 dataset, we can plot the histogram of tl_mm. Since histogram works for single variable that contains quantitative values, you can not bother looking for relationship as we have seen in previous plots, but histogram offers an opportunity to answer question like\n\nWhat are the smallest and largest values of tl_mm?\nWhat is the center value? 3 How does these values spread out?\n\nWe can make a histogram shown in Figure 19 by simply setting aes(x = tl_mm) and add geom_histogram(). Within the geom_histogram(), we simply specify the number of bins bins = 30, fill color for the colum and also the color separating each columns of the histogram with col == \"red\" and fill = \"red\". However, a word of caution regarding histograms—bin size matters. The reproducible code to plot Figure 19 is written as;\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm)) +\n  geom_histogram(bins = 30, fill = \"red\", color = \"red\", alpha = 0.4)+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 19: Histogram of total length\n\n\n\n\n\nThe resulting histogram gives us an idea of the range of total length of fish we can expect from the sample. You may be interested to compare histogram of the data values sampled from two or sites. For example, in our case, we are interested to compare the distribution of total length using samples collected from Mombasa and Voi sites. We simply add the fill = site argument in the aes function\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm, fill = site)) +\n  geom_histogram(bins = 50, alpha = 0.6)+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 20: Histogram of total length by sites\n\n\n\n\n\nThe histogram of Mombasa and Voi is plotted as shown in Figure 20, however, despite the transparency level of the bins is set to 0.6 (alpha = .6), yet the bins from Mombasa are masked with bins from Voi. The voi bins are plotted over the Mombasa ones and prevent us to visualize the underneath Mombasa bins. To correct for this issue, we need to parse position = \"identity\"in the geom_bin, which create an different color where the Mombasa and Voi bins are intersected.\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm, fill = site)) +\n  geom_histogram(bins = 50, alpha = 0.6, position = \"identity\")+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 21: Histogram of total length by sites\n\n\n\n\n\n\n\n\nIt is often useful to visualise the distribution of a numerical variable. Comparing the distributions of different groups can lead to important insights. Visualising distributions is also essential when checking assumptions used for various statistical tests (sometimes called initial data analysis). In this section we will illustrate how this can be done using the diamonds data from the ggplot2 package, which you started to explore in Chapter 2.\nAn advantage with frequency polygons is that they can be used to compare groups, e.g. diamonds with different cuts, without facetting:\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm, color = site)) +\n  geom_freqpoly(alpha = 0.6, position = \"identity\")+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 22: Frequency polygon of total length by sites\n\n\n\n\n\nIt is clear from this figure that the total length of fish from Voi is larger in size than those from Mombasa. The polygons have roughly the same shape, except the shape of Mombasa a long right tail indicating the presence of outlier points.\n\n\n\nIn some cases, we are more interested in the shape of the distribution than in the actual counts in the different bins. Density plots are similar to frequency polygons but show an estimate of the density function of the underlying random variable. These estimates are smooth curves that are scaled so that the area below them is 1 (i.e. scaled to be proper density functions):\n\n#|\n\n  ggplot(data = lfq4,\n       aes(x = tl_mm, fill = site)) +\n  geom_density(alpha = 0.4, position = \"identity\")+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 23: Density plot of total length by sites\n\n\n\n\n\nFrom Figure 23, it’s clear that small size fish tend to have better total length, which wasn’t obvious from the frequency polygons. However, the plot does not provide any information about how common different total length are.\n\n\n\nThe boxplot is a standardized way of displaying the distribution of data based on the five number summary: minimum, first quantile, median, third quantile, and maximum. Boxplots are useful for detecting outliers and for comparing distributions. These five number summary also called the 25th percentile, median, and 75th percentile of the quantitative data. The whisker (vertical lines) capture roungly 99% of a distribution, and observation outside this range are plotted as points representing outliers as shown in Figure 24.\n\n\n\n\n\n\n\n\nFigure 24: Conceputal boxplot diagram\n\n\n\n\n\nBoxplots is one of statistical plot that present continuous variable and in ggplot a geom_boxplot() function is dedicated for that. The aes function always have at least two arguments. The first argument should be a categrial variable and the second one is numeric.\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm)) +\n  geom_boxplot(alpha = 0.6, position = \"identity\")+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 25: Boxplot of total length by sites\n\n\n\n\n\nthe geom_boxplot() has outlier_ arguments that allows to highlight and modify the color, shape, size, alpha … etc of outliers —extreme observation. For instance, you can highlight the outlier with;\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm, fill = site)) +\n  geom_boxplot(alpha = 0.6, position = \"identity\", outlier.colour = \"red\", outlier.color = )+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 26: Boxplot of total length by sites\n\n\n\n\n\nWe can also map the fill and color to variable in to distinguish boxplot. for example, we can specify the fill = site argument in the aes() to fill the boxplot based on site.\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm, fill = site)) +\n  geom_boxplot(alpha = 0.6, position = \"identity\", outlier.colour = \"red\", outlier.color = )+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 27: Boxplot of total length and color to distinguish sites\n\n\n\n\n\nWe can add the points on top of the boxplot with the geom_jitter(). It also allows for specifying other arguments like colors and width of the points.\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm, fill = site)) +\n  geom_boxplot(alpha = 0.6, position = \"identity\", \n               outlier.colour = \"red\", outlier.color = )+\n  geom_jitter(width = .1, height = .5, alpha = 0.1)+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 28: Boxplot with points of total length by sites\n\n\n\n\n\n\n\n\nInstead of using a boxplot, we can use a violin plot. Each group is represented by a “violin”, given by a rotated and duplicated density plot:\n\n  ggplot(data = lfq4,\n       aes(x = site, y = tl_mm, fill = site)) +\n  geom_violin(alpha = 0.6, position = \"identity\")+\n  labs(x = \"Sites\", y = \"Total length (mm)\")+\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 29: Violin of total length by sites\n\n\n\n\n\n\n\n\nBar graphs are perhaps the widely used plot. They are typically used to display count values on the y-axis for different groups on the x-axis. There is an important distinction you should be aware of when making bar graphs. The height of a bar in barplot may represent either the counts or percentage of elements in the dataset. Let’s begin with the former—count. We use the shrimps_cleaned.csv dataset, which contains weight and length of four shrimp species. To access the variable and values of this file we need to load the file using a read_csv function as the code in the chunk below highlight;\n\nshrimp = read_csv(\"../data/tidy/shrimps_cleaned.csv\")\n\nThe sample dataset of shrimp is shown in Table 2. It contain six variables year, season, tide, species, weight (total_wt_kg) and length (tl_mm).\n\n\n\n\nTable 2: Shrimp dataset\n\n\n\n\n\n\n\n\n\n\nyear\nseason\ntide\nspecies\ntotal_wt_kg\ntl_mm\n\n\n\n\n2008\nWET\nSTF\nMetapenaeus monoceros\n2.0\n21\n\n\n2008\nWET\nSTF\nMetapenaeus monoceros\n2.0\n20\n\n\n2008\nWET\nSTF\nMetapenaeus monoceros\n2.0\n19\n\n\n2012\nDRY\nSTN\nPenaeus monodon\n1.7\n12\n\n\n2012\nDRY\nSTN\nFenneropenaeus indicus\n1.7\n14\n\n\n2012\nDRY\nSTN\nPenaeus monodon\n1.7\n11\n\n\n\n\n\n\n\n\n\n\n\nWe realize that the scientific names are too long and may not fit into the plotting area. Therefore, we use a case_when function from dplyr package to change species name and assign it as a new variable called species.short\n\nshrimp = shrimp %&gt;% \n  mutate(species.short = case_when(\n    species == \"Metapenaeus monoceros\"~ \"M.monoceros\",\n    species == \"Penaeus monodon\"~ \"P.monodon\",\n    species == \"Fenneropenaeus indicus\"~ \"F.indicus\",\n    species == \"Penaeus semisulcatus\"~ \"P.semisulcatus\")\n    ) %&gt;% \n  relocate(species.short, .after = species)\n\n\n\nTo make the bar graph that show the number of shrimp per species over the sampling period you you simply specify the the variable species in the x coordinates in the aesthetic and add the geom_bar()\n\nggplot(data = shrimp, aes(x = species.short))+\n  geom_bar()+\n  labs(x = \"Species\", y= \"Frequency\")\n\n\n\n\n\n\n\nFigure 30: Frequency of shrimp species\n\n\n\n\n\nThen to stack the bar based on the sampling season, we add the argument fill = season in aes() part\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar()+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 31: Frequency of shrimp species by season\n\n\n\n\n\nYou can flip the order of bar with position = position_stack(reverse = TRUE)\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_stack(reverse = TRUE))+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 32: Frequency of shrimp species by season\n\n\n\n\n\nInstead of stacking, you can dodge the bar with position = position_dodge() argument\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_dodge())+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 33: Frequency of shrimp species by season with span\n\n\n\n\n\nWe notice that the species that only appear one season, the count for that species is span across and make the bar wideer than those species occur in both seasons. We can fix that by parsing position = position_dodge(preserve = \"single\") in the geom_bar function\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_dodge(preserve = \"single\"))+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 34: Frequency of shrimp species by season without span\n\n\n\n\n\nTo add a black stroke color of the bar, add the argument col = \"black\" inside the geom_bar()\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_dodge(preserve = \"single\"), color = \"black\")+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 35: Frequency of shrimp species by season without span with black bar color\n\n\n\n\n\nAnd to specify the width of the bar you specify a value in width=.75 argument in geom_bar()\n\nggplot(data = shrimp, aes(x = species.short, fill = season))+\n  geom_bar(position = position_dodge(preserve = \"single\"), color = \"black\", width = .75)+\n  labs(x = \"Species\", y =\"Frequency\")\n\n\n\n\n\n\n\nFigure 36: Frequency of shrimp species by season without span with black bar color\n\n\n\n\n\n\n\n\nWe have seen how to make barplot that show the count with geom_bar(). You can also use the barplot to show the values with the geom_col() function and specify what variables you want on the x and y axis. For instance, we want to show percentage of shrimp species by season. Because the geom_col() requires summarized statistics, we need to compute the percentage for each season as the chunk below highlight.\n\nshrimp.pct = shrimp %&gt;% \n  group_by(species.short, season) %&gt;% \n  summarise(n = n()) %&gt;% \n  mutate(pct = n/sum(n), \n         pct = (pct * 100) %&gt;% round(2))\n\nshrimp.pct\n\n# A tibble: 6 × 4\n# Groups:   species.short [4]\n  species.short  season     n   pct\n  &lt;chr&gt;          &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt;\n1 F.indicus      DRY      404 100  \n2 M.monoceros    DRY      539  86.9\n3 M.monoceros    WET       81  13.1\n4 P.monodon      DRY      738  52.4\n5 P.monodon      WET      671  47.6\n6 P.semisulcatus DRY      227 100  \n\n\nOnce we have computed the statistics, we can use them to make barplot. Note that unlike the geom_bar(), which need only the x variable, geom_col() requires x and y variables specified. For illustration, we specified the x = species, and y = pct in the aes() to make a barplot that show the percentage of shrimp by season (Figure 37).\n\nggplot(data = shrimp.pct, aes(x = species.short, y = pct, fill = season))+\n  geom_col(position = position_dodge(preserve = \"single\"), color = \"black\", width = .75)+\n  labs(x = \"Species\", y =\"Percentage\")\n\n\n\n\n\n\n\nFigure 37: Percentage of shrimp species by season without span with black bar color\n\n\n\n\n\n\n\n\n\nA pie chart is a disk divided into pie-shaped pieces proportional to the relative frequencies of the classes. To obtain angle for any class, we multiply the relative frequencies by 360 degree, which corresponds to the complete circle. Either variables or attributes can be portrayed in this manner, but a pie chart is especially useful for attributes. A pie diagram for contribution of different fish groups/species to the total fish landings at a landing site of a river is shown in Figure 38.\n\nshrimp %&gt;% \n  group_by(species) %&gt;% \n  summarise(n = n()) %&gt;% \n  mutate(pct = round(n/sum(n)*100), 2) %&gt;% \n  mutate(species = str_replace(string = species, pattern = \" \", replacement = \"\\n\")) %&gt;% \n  mutate(label = paste0(\"(\",pct,\"%\",\")\")) %&gt;% \n  ggpubr::ggpie(x = \"pct\", label = \"label\", fill = \"species\", lab.pos = \"in\", palette = \"jama\", color = \"ivory\", ggtheme = theme_void(), )\n\n\n\n\n\n\n\nFigure 38: Percentage composition of prawn species\n\n\n\n\n\nAn extended pie chart is donut shown in Figure 39\n\nshrimp %&gt;% \n  group_by(species) %&gt;% \n  summarise(n = n()) %&gt;% \n  mutate(pct = round(n/sum(n)*100), 2) %&gt;% \n  mutate(species = str_replace(string = species, pattern = \" \", replacement = \"\\n\")) %&gt;% \n  mutate(label = paste0(\"(\",pct,\"%\",\")\")) %&gt;% \n  ggpubr::ggdonutchart(x = \"pct\", label = \"label\", fill = \"species\", lab.pos = \"in\", palette = \"jama\", color = \"ivory\", ggtheme = theme_void())\n\n\n\n\n\n\n\nFigure 39: Percentage composition of prawn species\n\n\n\n\n\n\n\n\n\nshrimp %&gt;% \n  group_by(species.short) %&gt;% \n  count() %&gt;% \n  arrange(-n) %&gt;% \n  ggplot(aes(x = reorder(species.short,n), y = n, \n             fill = species.short), stat = \"identity\")+\n  geom_col() +\n  coord_polar(theta = \"y\")+\n  theme_bw() +\n  theme(axis.title = element_blank(), legend.position = \"right\", axis.text.y = element_blank(), axis.ticks = element_blank())+\n  scale_fill_brewer(palette = \"Set2\", name = \"Species\")\n\n\n\n\n\n\n\nFigure 40: Barplot with polar transformation\n\n\n\n\n\n\nshrimp %&gt;% \n  ggplot() +\n  geom_bar(aes(x = tide, fill = species.short),\n           color = \"ivory\") +\n  labs(x = \"Tide\", y = \"Count\") +\n  coord_polar()+\n  theme_bw() +\n  theme(axis.title = element_blank(), \n        legend.position = \"right\")+\n  scale_fill_brewer(palette = \"Set2\", name = \"Species\")\n\n\n\n\n\n\n\nFigure 41: Stacked barplot with polar transformation\n\n\n\n\n\n\n\n\nAlthough the ggridges package provides geom_ridgeline and geom_density_ridges, we focus on the latter because it has ability to estimates data densities and then draws those using ridgelines.The geom geom_density_ridges calculates density estimates from the provided data and then plots those, using the ridgeline visualization.\n\nlfq4 %&gt;% \n  mutate(months = lubridate::month(date, label = TRUE)) %&gt;%\n  ggplot()+\n  ggridges::geom_density_ridges(aes(x = tl_mm, y = months, fill = site), alpha = .7)+\n  scale_fill_brewer(palette = \"Set2\", name = \"Sampling\\nsite\")+\n  theme_minimal()+\n  theme(legend.position = c(.85,.2), legend.background = element_rect())+\n  labs(y = \"Months\", x = \"Total length (mm.)\")"
  },
  {
    "objectID": "posts/basicplots/index.html#combining-multiple-plots",
    "href": "posts/basicplots/index.html#combining-multiple-plots",
    "title": "Basic plots with ggplot2",
    "section": "2 Combining multiple plots",
    "text": "2 Combining multiple plots\nWhen exploring data with many variables, you’ll often want to make the same kind of plot (e.g. a violin plot) for several variables. It will frequently make sense to place these side-by-side in the same plot window. The patchwork package extends ggplot2 by letting you do just that. Let’s install it:\ninstall.packages(\"patchwork\")\nThen load a package in the workspace\n\nrequire(patchwork)\n\nTo use patchwork (Pedersen, 2020), save each plot as a plot object :\n\nplot.tl = ggplot(data = lfq4,\n       aes(x = tl_mm, fill = site)) +\n  geom_density(alpha = 0.4, position = \"identity\")+\n  labs(x = \"Total length (mm)\", y = \"Frequency\")+\n  theme_minimal()\n\n plot.wt = ggplot(data = lfq4,\n       aes(x = wt_gm, fill = site)) +\n  geom_density(alpha = 0.4, position = \"identity\")+\n  labs(x = \"Weight (gram)\", y = \"Frequency\")+\n  theme_minimal()+\n   theme(legend.position = \"none\")\n\nthen add them together\n\nplot.tl + plot.wt\n\n\n\n\n\n\n\nFigure 42: Density plot by sites for total length (left panel) and weight (right panel)\n\n\n\n\n\n`\n\nplot.tl / plot.wt\n\n\n\n\n\n\n\nFigure 43: Density plot by sites for total length (top panel) and weight (bottom panel)\n\n\n\n\n\nWe need first to extract monsoon seasons from the dataset. We know from literature that the coasal waters of East Africa is affected by monsoon season, which is influenced trade winds, which is broadly categorized as;\n\nNortheast monsoon season — November through March\nSoutheast monsoon season — May to september\nIntermonsoon season — April and October\n\nWe can use the month information to break our dataset into three monsoon seasons as;\n\nlfq4.season = lfq4 %&gt;% \n  mutate(month = lubridate::month(date),\n         season = case_when(month &gt; 10 | month &lt; 4 ~ \"NE\",\n                            month &gt;=5 & month &lt; 10 ~ \"SE\",\n                            month == 4 | month == 10 ~ \"INT\")) %&gt;% select(-month)\n\n\nplot.int =lfq4.season %&gt;% \n  filter(site == \"Voi\" & season == \"INT\") %&gt;% \n  ggplot(aes(x = tl_mm, y = wt_gm))+\n  geom_point(alpha = .2)+\n  theme_bw()+\n  scale_x_continuous(name = \"Total length (mm)\")+\n  scale_y_continuous(name = \"Weight (gram)\")+\n  annotate(geom = \"label\",x = 120, y = 80, label = \"Northeast\\nSeason\")\n\nplot.ne = lfq4.season %&gt;% \n  filter(site == \"Voi\" & season == \"NE\") %&gt;% \n  ggplot(aes(x = tl_mm, y = wt_gm))+\n  geom_point(alpha = .2)+\n  theme_bw()+\n  scale_x_continuous(name = \"Total length (mm)\")+\n  scale_y_continuous(name = \"Weight (gram)\")+\n  annotate(geom = \"label\",x = 140, y = 80, label = \"Southeast\\nSeason\")\n\nplot.se = lfq4.season %&gt;% \n  filter(site == \"Voi\" & season == \"SE\") %&gt;% \n  ggplot(aes(x = tl_mm, y = wt_gm))+\n  geom_point(alpha = .2)+\n  theme_bw()+\n  scale_x_continuous(name = \"Total length (mm)\")+\n  scale_y_continuous(name = \"Weight (gram)\")+\n  annotate(geom = \"label\",x = 120, y = 80, label = \"Inter\\n Monsoon\")\n\nplot.all = lfq4.season %&gt;% \n  filter(site == \"Voi\") %&gt;% \n  ggplot(aes(x = tl_mm, y = wt_gm, color = season))+\n  geom_point(alpha = .2)+\n  theme_bw()+\n  scale_x_continuous(name = \"Total length (mm)\")+\n  scale_y_continuous(name = \"Weight (gram)\")+\n  theme(legend.position = c(.2,.8))\n\nYuo may plot One row with three plots and one row with a single plot\n\n(plot.ne + plot.se + plot.int)/\n  plot.all\n\n\n\n\n\n\n\n\nOr one column with three plots and one column with a single plot `\n\nplot.all | (plot.ne / plot.se / plot.int)"
  },
  {
    "objectID": "posts/basicplots/index.html#labelling-outliers",
    "href": "posts/basicplots/index.html#labelling-outliers",
    "title": "Basic plots with ggplot2",
    "section": "3 Labelling outliers",
    "text": "3 Labelling outliers\nInteractive plots are great when exploring a dataset but are not always possible to use in other contexts, e.g. for printed reports and some presentations. In these other cases, we can instead annotate the plot with notes about outliers. One way to do this is to use a geom called geom_text.\n\nlfq4.season %&gt;% \n  filter(!site == \"Voi\") %&gt;% \n  ggplot(aes(x = season, y = wt_gm, fill = season))+\n  geom_boxplot(alpha = .4, width = .29)+\n  ggrepel::geom_text_repel(aes(label = if_else( wt_gm &gt; 175, site, \"\"))) +\n  theme_bw()+\n  scale_x_discrete(name = \"Monsoon season\")+\n  scale_y_continuous(name = \"Weight (gram)\")+\n  theme(legend.position = \"none\")"
  },
  {
    "objectID": "posts/basicplots/index.html#add-on-packages",
    "href": "posts/basicplots/index.html#add-on-packages",
    "title": "Basic plots with ggplot2",
    "section": "4 Add-on packages",
    "text": "4 Add-on packages\nThe R community has developed packages that extend the capability of ggplot2. Some of the packages include:\n\nmetR: Provide addition tools for plotting filled contour, and label contour lines\nggrepel: Contains tools for automatically position non-overlapping text labels\nggspatial: Spatial Data Framework for ggplot2\nRcolorBrewer: Contains color palettes for continuous and discrete plots\ncowplot: Contains addition themes and tools to combine ggplot2 plots in one panel\negg: Provide tools for plot aligning and symmetrised ggplot2 plots\noce: Provide color pallete for visualization of Oceanographic Data\nggsn: Provide tools for mapping North symbols and scale bars on maps created with ggplot2\ngganimate: convert static ggplot2 plots to animations\nggformula: adds some additional plot options to ggplot2\nsf : Add capabilities of ggplot2 to map spatial data such as simple features\nggthemes: contains extra themes, scales, and geoms, and functions for and related to ggplot2\nggridges: extend the geom_density function by plotiing closed polygons insted of ridgelines\nggpmisc"
  },
  {
    "objectID": "posts/timeline/index.html",
    "href": "posts/timeline/index.html",
    "title": "Creating a Timeline graphic using R and ggplot2",
    "section": "",
    "text": "In this post we’re going to be using R and ggplot2 to create a project timeline with milestones and milestone statuses.\nThe finished product will look like as illustrated in Figure 1\n\n\n\n\n\n\nFigure 1: A timeline of the Milestone for learning Modern\n\n\n\n\n\n\nCitationBibTeX citation:@online{semba2023,\n  author = {Semba, Masumbuko},\n  title = {Creating a {Timeline} Graphic Using {R} and Ggplot2},\n  date = {2023-11-24},\n  url = {https://lugoga.github.io/kitaa/posts/timeline/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSemba, M., 2023. Creating a Timeline graphic using R and ggplot2 [WWW\nDocument]. URL https://lugoga.github.io/kitaa/posts/timeline/"
  }
]